"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Editable: () => Editable,
  EditableInput: () => EditableInput,
  EditablePreview: () => EditablePreview,
  EditableTextarea: () => EditableTextarea,
  useEditable: () => useEditable,
  useEditableControls: () => useEditableControls,
  useEditableState: () => useEditableState,
  useEditableStyles: () => useEditableStyles
});
module.exports = __toCommonJS(src_exports);

// ../../react-shim.js
var import_react = __toESM(require("react"));

// src/editable.tsx
var import_system = require("@chakra-ui/system");
var import_utils2 = require("@chakra-ui/utils");

// src/editable-context.ts
var import_react_utils = require("@chakra-ui/react-utils");
var [EditableStylesProvider, useEditableStyles] = (0, import_react_utils.createContext)({
  name: `EditableStylesContext`,
  errorMessage: `useEditableStyles returned is 'undefined'. Seems you forgot to wrap the components in "<Editable />" `
});
var [EditableProvider, useEditableContext] = (0, import_react_utils.createContext)({
  name: "EditableContext",
  errorMessage: "useEditableContext: context is undefined. Seems you forgot to wrap the editable components in `<Editable />`"
});

// src/use-editable.ts
var import_hooks = require("@chakra-ui/hooks");
var import_react_utils2 = require("@chakra-ui/react-utils");
var import_utils = require("@chakra-ui/utils");
var import_react2 = require("react");
function useEditable(props = {}) {
  const {
    onChange: onChangeProp,
    onCancel: onCancelProp,
    onSubmit: onSubmitProp,
    value: valueProp,
    isDisabled,
    defaultValue,
    startWithEditView,
    isPreviewFocusable = true,
    submitOnBlur = true,
    selectAllOnFocus = true,
    placeholder,
    onEdit: onEditProp,
    ...htmlProps
  } = props;
  const defaultIsEditing = Boolean(startWithEditView && !isDisabled);
  const [isEditing, setIsEditing] = (0, import_react2.useState)(defaultIsEditing);
  const [value, setValue] = (0, import_hooks.useControllableState)({
    defaultValue: defaultValue || "",
    value: valueProp,
    onChange: onChangeProp
  });
  const [prevValue, setPrevValue] = (0, import_react2.useState)(value);
  const inputRef = (0, import_react2.useRef)(null);
  const previewRef = (0, import_react2.useRef)(null);
  const editButtonRef = (0, import_react2.useRef)(null);
  const cancelButtonRef = (0, import_react2.useRef)(null);
  const submitButtonRef = (0, import_react2.useRef)(null);
  (0, import_hooks.useFocusOnPointerDown)({
    ref: inputRef,
    enabled: isEditing,
    elements: [cancelButtonRef, submitButtonRef]
  });
  const isInteractive = !isEditing && !isDisabled;
  (0, import_hooks.useSafeLayoutEffect)(() => {
    if (isEditing) {
      (0, import_utils.focus)(inputRef.current, {
        selectTextIfInput: selectAllOnFocus
      });
    }
  }, []);
  (0, import_hooks.useUpdateEffect)(() => {
    if (!isEditing) {
      (0, import_utils.focus)(editButtonRef.current);
      return;
    }
    (0, import_utils.focus)(inputRef.current, {
      selectTextIfInput: selectAllOnFocus
    });
    onEditProp == null ? void 0 : onEditProp();
  }, [isEditing, onEditProp, selectAllOnFocus]);
  const onEdit = (0, import_react2.useCallback)(() => {
    if (isInteractive) {
      setIsEditing(true);
    }
  }, [isInteractive]);
  const onUpdatePrevValue = (0, import_react2.useCallback)(() => {
    setPrevValue(value);
  }, [value]);
  const onCancel = (0, import_react2.useCallback)(() => {
    setIsEditing(false);
    setValue(prevValue);
    onCancelProp == null ? void 0 : onCancelProp(prevValue);
  }, [onCancelProp, setValue, prevValue]);
  const onSubmit = (0, import_react2.useCallback)(() => {
    setIsEditing(false);
    setPrevValue(value);
    onSubmitProp == null ? void 0 : onSubmitProp(value);
  }, [value, onSubmitProp]);
  const onChange = (0, import_react2.useCallback)((event) => {
    setValue(event.currentTarget.value);
  }, [setValue]);
  const onKeyDown = (0, import_react2.useCallback)((event) => {
    const eventKey = (0, import_utils.normalizeEventKey)(event);
    const keyMap = {
      Escape: onCancel,
      Enter: (event2) => {
        if (!event2.shiftKey && !event2.metaKey) {
          onSubmit();
        }
      }
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [onCancel, onSubmit]);
  const onKeyDownWithoutSubmit = (0, import_react2.useCallback)((event) => {
    const eventKey = (0, import_utils.normalizeEventKey)(event);
    const keyMap = {
      Escape: onCancel
    };
    const action = keyMap[eventKey];
    if (action) {
      event.preventDefault();
      action(event);
    }
  }, [onCancel]);
  const isValueEmpty = (0, import_utils.isEmpty)(value);
  const onBlur = (0, import_react2.useCallback)((event) => {
    const relatedTarget = (0, import_utils.getRelatedTarget)(event);
    const targetIsCancel = (0, import_utils.contains)(cancelButtonRef.current, relatedTarget);
    const targetIsSubmit = (0, import_utils.contains)(submitButtonRef.current, relatedTarget);
    const isValidBlur = !targetIsCancel && !targetIsSubmit;
    if (isValidBlur) {
      if (submitOnBlur) {
        onSubmit();
      } else {
        onCancel();
      }
    }
  }, [submitOnBlur, onSubmit, onCancel]);
  const getPreviewProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => {
    const tabIndex = isInteractive && isPreviewFocusable ? 0 : void 0;
    return {
      ...props2,
      ref: (0, import_react_utils2.mergeRefs)(ref, previewRef),
      children: isValueEmpty ? placeholder : value,
      hidden: isEditing,
      "aria-disabled": (0, import_utils.ariaAttr)(isDisabled),
      tabIndex,
      onFocus: (0, import_utils.callAllHandlers)(props2.onFocus, onEdit, onUpdatePrevValue)
    };
  }, [
    isDisabled,
    isEditing,
    isInteractive,
    isPreviewFocusable,
    isValueEmpty,
    onEdit,
    onUpdatePrevValue,
    placeholder,
    value
  ]);
  const getInputProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    hidden: !isEditing,
    placeholder,
    ref: (0, import_react_utils2.mergeRefs)(ref, inputRef),
    disabled: isDisabled,
    "aria-disabled": (0, import_utils.ariaAttr)(isDisabled),
    value,
    onBlur: (0, import_utils.callAllHandlers)(props2.onBlur, onBlur),
    onChange: (0, import_utils.callAllHandlers)(props2.onChange, onChange),
    onKeyDown: (0, import_utils.callAllHandlers)(props2.onKeyDown, onKeyDown),
    onFocus: (0, import_utils.callAllHandlers)(props2.onFocus, onUpdatePrevValue)
  }), [
    isDisabled,
    isEditing,
    onBlur,
    onChange,
    onKeyDown,
    onUpdatePrevValue,
    placeholder,
    value
  ]);
  const getTextareaProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    hidden: !isEditing,
    placeholder,
    ref: (0, import_react_utils2.mergeRefs)(ref, inputRef),
    disabled: isDisabled,
    "aria-disabled": (0, import_utils.ariaAttr)(isDisabled),
    value,
    onBlur: (0, import_utils.callAllHandlers)(props2.onBlur, onBlur),
    onChange: (0, import_utils.callAllHandlers)(props2.onChange, onChange),
    onKeyDown: (0, import_utils.callAllHandlers)(props2.onKeyDown, onKeyDownWithoutSubmit),
    onFocus: (0, import_utils.callAllHandlers)(props2.onFocus, onUpdatePrevValue)
  }), [
    isDisabled,
    isEditing,
    onBlur,
    onChange,
    onKeyDownWithoutSubmit,
    onUpdatePrevValue,
    placeholder,
    value
  ]);
  const getEditButtonProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => ({
    "aria-label": "Edit",
    ...props2,
    type: "button",
    onClick: (0, import_utils.callAllHandlers)(props2.onClick, onEdit),
    ref: (0, import_react_utils2.mergeRefs)(ref, editButtonRef),
    disabled: isDisabled
  }), [onEdit, isDisabled]);
  const getSubmitButtonProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => ({
    ...props2,
    "aria-label": "Submit",
    ref: (0, import_react_utils2.mergeRefs)(submitButtonRef, ref),
    type: "button",
    onClick: (0, import_utils.callAllHandlers)(props2.onClick, onSubmit),
    disabled: isDisabled
  }), [onSubmit, isDisabled]);
  const getCancelButtonProps = (0, import_react2.useCallback)((props2 = {}, ref = null) => ({
    "aria-label": "Cancel",
    id: "cancel",
    ...props2,
    ref: (0, import_react_utils2.mergeRefs)(cancelButtonRef, ref),
    type: "button",
    onClick: (0, import_utils.callAllHandlers)(props2.onClick, onCancel),
    disabled: isDisabled
  }), [onCancel, isDisabled]);
  return {
    isEditing,
    isDisabled,
    isValueEmpty,
    value,
    onEdit,
    onCancel,
    onSubmit,
    getPreviewProps,
    getInputProps,
    getTextareaProps,
    getEditButtonProps,
    getSubmitButtonProps,
    getCancelButtonProps,
    htmlProps
  };
}

// src/editable.tsx
var Editable = (0, import_system.forwardRef)(function Editable2(props, ref) {
  const styles = (0, import_system.useMultiStyleConfig)("Editable", props);
  const ownProps = (0, import_system.omitThemingProps)(props);
  const { htmlProps, ...context } = useEditable(ownProps);
  const { isEditing, onSubmit, onCancel, onEdit } = context;
  const _className = (0, import_utils2.cx)("chakra-editable", props.className);
  const children = (0, import_utils2.runIfFn)(props.children, {
    isEditing,
    onSubmit,
    onCancel,
    onEdit
  });
  return /* @__PURE__ */ import_react.default.createElement(EditableProvider, {
    value: context
  }, /* @__PURE__ */ import_react.default.createElement(EditableStylesProvider, {
    value: styles
  }, /* @__PURE__ */ import_react.default.createElement(import_system.chakra.div, {
    ref,
    ...htmlProps,
    className: _className
  }, children)));
});
if (import_utils2.__DEV__) {
  Editable.displayName = "Editable";
}

// src/editable-input.tsx
var import_system2 = require("@chakra-ui/system");
var import_utils3 = require("@chakra-ui/utils");

// src/shared.ts
var commonStyles = {
  fontSize: "inherit",
  fontWeight: "inherit",
  textAlign: "inherit",
  bg: "transparent"
};

// src/editable-input.tsx
var EditableInput = (0, import_system2.forwardRef)(function EditableInput2(props, ref) {
  const { getInputProps } = useEditableContext();
  const styles = useEditableStyles();
  const inputProps = getInputProps(props, ref);
  const _className = (0, import_utils3.cx)("chakra-editable__input", props.className);
  return /* @__PURE__ */ import_react.default.createElement(import_system2.chakra.input, {
    ...inputProps,
    __css: {
      outline: 0,
      ...commonStyles,
      ...styles.input
    },
    className: _className
  });
});
if (import_utils3.__DEV__) {
  EditableInput.displayName = "EditableInput";
}

// src/editable-textarea.tsx
var import_system3 = require("@chakra-ui/system");
var import_utils4 = require("@chakra-ui/utils");
var EditableTextarea = (0, import_system3.forwardRef)(function EditableTextarea2(props, ref) {
  const { getTextareaProps } = useEditableContext();
  const styles = useEditableStyles();
  const textareaProps = getTextareaProps(props, ref);
  const _className = (0, import_utils4.cx)("chakra-editable__textarea", props.className);
  return /* @__PURE__ */ import_react.default.createElement(import_system3.chakra.textarea, {
    ...textareaProps,
    __css: {
      outline: 0,
      ...commonStyles,
      ...styles.textarea
    },
    className: _className
  });
});
if (import_utils4.__DEV__) {
  EditableTextarea.displayName = "EditableTextarea";
}

// src/editable-preview.tsx
var import_system4 = require("@chakra-ui/system");
var import_utils5 = require("@chakra-ui/utils");
var EditablePreview = (0, import_system4.forwardRef)(function EditablePreview2(props, ref) {
  const { getPreviewProps } = useEditableContext();
  const styles = useEditableStyles();
  const previewProps = getPreviewProps(props, ref);
  const _className = (0, import_utils5.cx)("chakra-editable__preview", props.className);
  return /* @__PURE__ */ import_react.default.createElement(import_system4.chakra.span, {
    ...previewProps,
    __css: {
      cursor: "text",
      display: "inline-block",
      ...commonStyles,
      ...styles.preview
    },
    className: _className
  });
});
if (import_utils5.__DEV__) {
  EditablePreview.displayName = "EditablePreview";
}

// src/use-editable-controls.tsx
function useEditableControls() {
  const {
    isEditing,
    getEditButtonProps,
    getCancelButtonProps,
    getSubmitButtonProps
  } = useEditableContext();
  return {
    isEditing,
    getEditButtonProps,
    getCancelButtonProps,
    getSubmitButtonProps
  };
}

// src/use-editable-state.tsx
function useEditableState() {
  const { isEditing, onSubmit, onCancel, onEdit, isDisabled } = useEditableContext();
  return {
    isEditing,
    onSubmit,
    onCancel,
    onEdit,
    isDisabled
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Editable,
  EditableInput,
  EditablePreview,
  EditableTextarea,
  useEditable,
  useEditableControls,
  useEditableState,
  useEditableStyles
});
