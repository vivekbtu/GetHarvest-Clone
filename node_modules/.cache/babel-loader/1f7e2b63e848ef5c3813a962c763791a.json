{"ast":null,"code":"import { isMouseEvent, isTouchEvent } from './utils/event-type.mjs';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { distance, pipe } from 'popmotion';\n/**\n * @internal\n */\n\nclass PanSession {\n  constructor(event, handlers) {\n    let {\n      transformPagePoint\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    /**\n     * @internal\n     */\n    this.startEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEvent = null;\n    /**\n     * @internal\n     */\n\n    this.lastMoveEventInfo = null;\n    /**\n     * @internal\n     */\n\n    this.handlers = {};\n\n    this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;\n      const info = getPanInfo(this.lastMoveEventInfo, this.history);\n      const isPanStarted = this.startEvent !== null; // Only start panning if the offset is larger than 3 pixels. If we make it\n      // any larger than this we'll want to reset the pointer history\n      // on the first update to avoid visual snapping to the cursoe.\n\n      const isDistancePastThreshold = distance(info.offset, {\n        x: 0,\n        y: 0\n      }) >= 3;\n      if (!isPanStarted && !isDistancePastThreshold) return;\n      const {\n        point\n      } = info;\n      const {\n        timestamp\n      } = getFrameData();\n      this.history.push(Object.assign(Object.assign({}, point), {\n        timestamp\n      }));\n      const {\n        onStart,\n        onMove\n      } = this.handlers;\n\n      if (!isPanStarted) {\n        onStart && onStart(this.lastMoveEvent, info);\n        this.startEvent = this.lastMoveEvent;\n      }\n\n      onMove && onMove(this.lastMoveEvent, info);\n    };\n\n    this.handlePointerMove = (event, info) => {\n      this.lastMoveEvent = event;\n      this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint); // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n\n      if (isMouseEvent(event) && event.buttons === 0) {\n        this.handlePointerUp(event, info);\n        return;\n      } // Throttle mouse move event to once per frame\n\n\n      sync.update(this.updatePoint, true);\n    };\n\n    this.handlePointerUp = (event, info) => {\n      this.end();\n      const {\n        onEnd,\n        onSessionEnd\n      } = this.handlers;\n      const panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n\n      if (this.startEvent && onEnd) {\n        onEnd(event, panInfo);\n      }\n\n      onSessionEnd && onSessionEnd(event, panInfo);\n    }; // If we have more than one touch, don't start detecting this gesture\n\n\n    if (isTouchEvent(event) && event.touches.length > 1) return;\n    this.handlers = handlers;\n    this.transformPagePoint = transformPagePoint;\n    const info = extractEventInfo(event);\n    const initialInfo = transformPoint(info, this.transformPagePoint);\n    const {\n      point\n    } = initialInfo;\n    const {\n      timestamp\n    } = getFrameData();\n    this.history = [Object.assign(Object.assign({}, point), {\n      timestamp\n    })];\n    const {\n      onSessionStart\n    } = handlers;\n    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));\n    this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n  }\n\n  updateHandlers(handlers) {\n    this.handlers = handlers;\n  }\n\n  end() {\n    this.removeListeners && this.removeListeners();\n    cancelSync.update(this.updatePoint);\n  }\n\n}\n\nfunction transformPoint(info, transformPagePoint) {\n  return transformPagePoint ? {\n    point: transformPagePoint(info.point)\n  } : info;\n}\n\nfunction subtractPoint(a, b) {\n  return {\n    x: a.x - b.x,\n    y: a.y - b.y\n  };\n}\n\nfunction getPanInfo(_ref, history) {\n  let {\n    point\n  } = _ref;\n  return {\n    point,\n    delta: subtractPoint(point, lastDevicePoint(history)),\n    offset: subtractPoint(point, startDevicePoint(history)),\n    velocity: getVelocity(history, 0.1)\n  };\n}\n\nfunction startDevicePoint(history) {\n  return history[0];\n}\n\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\n\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n\n  while (i >= 0) {\n    timestampedPoint = history[i];\n\n    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {\n      break;\n    }\n\n    i--;\n  }\n\n  if (!timestampedPoint) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n\n  if (time === 0) {\n    return {\n      x: 0,\n      y: 0\n    };\n  }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n\n  if (currentVelocity.x === Infinity) {\n    currentVelocity.x = 0;\n  }\n\n  if (currentVelocity.y === Infinity) {\n    currentVelocity.y = 0;\n  }\n\n  return currentVelocity;\n}\n\nexport { PanSession };","map":{"version":3,"names":["isMouseEvent","isTouchEvent","extractEventInfo","sync","getFrameData","cancelSync","secondsToMilliseconds","addPointerEvent","distance","pipe","PanSession","constructor","event","handlers","transformPagePoint","startEvent","lastMoveEvent","lastMoveEventInfo","updatePoint","info","getPanInfo","history","isPanStarted","isDistancePastThreshold","offset","x","y","point","timestamp","push","Object","assign","onStart","onMove","handlePointerMove","transformPoint","buttons","handlePointerUp","update","end","onEnd","onSessionEnd","panInfo","touches","length","initialInfo","onSessionStart","removeListeners","window","updateHandlers","subtractPoint","a","b","delta","lastDevicePoint","startDevicePoint","velocity","getVelocity","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity"],"sources":["C:/Users/bittu/Desktop/Unit4Project-React/my-project/node_modules/framer-motion/dist/es/gestures/PanSession.mjs"],"sourcesContent":["import { isMouseEvent, isTouchEvent } from './utils/event-type.mjs';\nimport { extractEventInfo } from '../events/event-info.mjs';\nimport sync, { getFrameData, cancelSync } from 'framesync';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { addPointerEvent } from '../events/use-pointer-event.mjs';\nimport { distance, pipe } from 'popmotion';\n\n/**\n * @internal\n */\nclass PanSession {\n    constructor(event, handlers, { transformPagePoint } = {}) {\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = () => {\n            if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n                return;\n            const info = getPanInfo(this.lastMoveEventInfo, this.history);\n            const isPanStarted = this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we'll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            const isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            const { point } = info;\n            const { timestamp } = getFrameData();\n            this.history.push(Object.assign(Object.assign({}, point), { timestamp }));\n            const { onStart, onMove } = this.handlers;\n            if (!isPanStarted) {\n                onStart && onStart(this.lastMoveEvent, info);\n                this.startEvent = this.lastMoveEvent;\n            }\n            onMove && onMove(this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = (event, info) => {\n            this.lastMoveEvent = event;\n            this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);\n            // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            sync.update(this.updatePoint, true);\n        };\n        this.handlePointerUp = (event, info) => {\n            this.end();\n            const { onEnd, onSessionEnd } = this.handlers;\n            const panInfo = getPanInfo(transformPoint(info, this.transformPagePoint), this.history);\n            if (this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don't start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        const info = extractEventInfo(event);\n        const initialInfo = transformPoint(info, this.transformPagePoint);\n        const { point } = initialInfo;\n        const { timestamp } = getFrameData();\n        this.history = [Object.assign(Object.assign({}, point), { timestamp })];\n        const { onSessionStart } = handlers;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(window, \"pointermove\", this.handlePointerMove), addPointerEvent(window, \"pointerup\", this.handlePointerUp), addPointerEvent(window, \"pointercancel\", this.handlePointerUp));\n    }\n    updateHandlers(handlers) {\n        this.handlers = handlers;\n    }\n    end() {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n    }\n}\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo({ point }, history) {\n    return {\n        point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    let i = history.length - 1;\n    let timestampedPoint = null;\n    const lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    const time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    const currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\nexport { PanSession };\n"],"mappings":"AAAA,SAASA,YAAT,EAAuBC,YAAvB,QAA2C,wBAA3C;AACA,SAASC,gBAAT,QAAiC,0BAAjC;AACA,OAAOC,IAAP,IAAeC,YAAf,EAA6BC,UAA7B,QAA+C,WAA/C;AACA,SAASC,qBAAT,QAAsC,8BAAtC;AACA,SAASC,eAAT,QAAgC,iCAAhC;AACA,SAASC,QAAT,EAAmBC,IAAnB,QAA+B,WAA/B;AAEA;AACA;AACA;;AACA,MAAMC,UAAN,CAAiB;EACbC,WAAW,CAACC,KAAD,EAAQC,QAAR,EAA+C;IAAA,IAA7B;MAAEC;IAAF,CAA6B,uEAAJ,EAAI;;IACtD;AACR;AACA;IACQ,KAAKC,UAAL,GAAkB,IAAlB;IACA;AACR;AACA;;IACQ,KAAKC,aAAL,GAAqB,IAArB;IACA;AACR;AACA;;IACQ,KAAKC,iBAAL,GAAyB,IAAzB;IACA;AACR;AACA;;IACQ,KAAKJ,QAAL,GAAgB,EAAhB;;IACA,KAAKK,WAAL,GAAmB,MAAM;MACrB,IAAI,EAAE,KAAKF,aAAL,IAAsB,KAAKC,iBAA7B,CAAJ,EACI;MACJ,MAAME,IAAI,GAAGC,UAAU,CAAC,KAAKH,iBAAN,EAAyB,KAAKI,OAA9B,CAAvB;MACA,MAAMC,YAAY,GAAG,KAAKP,UAAL,KAAoB,IAAzC,CAJqB,CAKrB;MACA;MACA;;MACA,MAAMQ,uBAAuB,GAAGf,QAAQ,CAACW,IAAI,CAACK,MAAN,EAAc;QAAEC,CAAC,EAAE,CAAL;QAAQC,CAAC,EAAE;MAAX,CAAd,CAAR,IAAyC,CAAzE;MACA,IAAI,CAACJ,YAAD,IAAiB,CAACC,uBAAtB,EACI;MACJ,MAAM;QAAEI;MAAF,IAAYR,IAAlB;MACA,MAAM;QAAES;MAAF,IAAgBxB,YAAY,EAAlC;MACA,KAAKiB,OAAL,CAAaQ,IAAb,CAAkBC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,KAAlB,CAAd,EAAwC;QAAEC;MAAF,CAAxC,CAAlB;MACA,MAAM;QAAEI,OAAF;QAAWC;MAAX,IAAsB,KAAKpB,QAAjC;;MACA,IAAI,CAACS,YAAL,EAAmB;QACfU,OAAO,IAAIA,OAAO,CAAC,KAAKhB,aAAN,EAAqBG,IAArB,CAAlB;QACA,KAAKJ,UAAL,GAAkB,KAAKC,aAAvB;MACH;;MACDiB,MAAM,IAAIA,MAAM,CAAC,KAAKjB,aAAN,EAAqBG,IAArB,CAAhB;IACH,CApBD;;IAqBA,KAAKe,iBAAL,GAAyB,CAACtB,KAAD,EAAQO,IAAR,KAAiB;MACtC,KAAKH,aAAL,GAAqBJ,KAArB;MACA,KAAKK,iBAAL,GAAyBkB,cAAc,CAAChB,IAAD,EAAO,KAAKL,kBAAZ,CAAvC,CAFsC,CAGtC;;MACA,IAAId,YAAY,CAACY,KAAD,CAAZ,IAAuBA,KAAK,CAACwB,OAAN,KAAkB,CAA7C,EAAgD;QAC5C,KAAKC,eAAL,CAAqBzB,KAArB,EAA4BO,IAA5B;QACA;MACH,CAPqC,CAQtC;;;MACAhB,IAAI,CAACmC,MAAL,CAAY,KAAKpB,WAAjB,EAA8B,IAA9B;IACH,CAVD;;IAWA,KAAKmB,eAAL,GAAuB,CAACzB,KAAD,EAAQO,IAAR,KAAiB;MACpC,KAAKoB,GAAL;MACA,MAAM;QAAEC,KAAF;QAASC;MAAT,IAA0B,KAAK5B,QAArC;MACA,MAAM6B,OAAO,GAAGtB,UAAU,CAACe,cAAc,CAAChB,IAAD,EAAO,KAAKL,kBAAZ,CAAf,EAAgD,KAAKO,OAArD,CAA1B;;MACA,IAAI,KAAKN,UAAL,IAAmByB,KAAvB,EAA8B;QAC1BA,KAAK,CAAC5B,KAAD,EAAQ8B,OAAR,CAAL;MACH;;MACDD,YAAY,IAAIA,YAAY,CAAC7B,KAAD,EAAQ8B,OAAR,CAA5B;IACH,CARD,CAjDsD,CA0DtD;;;IACA,IAAIzC,YAAY,CAACW,KAAD,CAAZ,IAAuBA,KAAK,CAAC+B,OAAN,CAAcC,MAAd,GAAuB,CAAlD,EACI;IACJ,KAAK/B,QAAL,GAAgBA,QAAhB;IACA,KAAKC,kBAAL,GAA0BA,kBAA1B;IACA,MAAMK,IAAI,GAAGjB,gBAAgB,CAACU,KAAD,CAA7B;IACA,MAAMiC,WAAW,GAAGV,cAAc,CAAChB,IAAD,EAAO,KAAKL,kBAAZ,CAAlC;IACA,MAAM;MAAEa;IAAF,IAAYkB,WAAlB;IACA,MAAM;MAAEjB;IAAF,IAAgBxB,YAAY,EAAlC;IACA,KAAKiB,OAAL,GAAe,CAACS,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBJ,KAAlB,CAAd,EAAwC;MAAEC;IAAF,CAAxC,CAAD,CAAf;IACA,MAAM;MAAEkB;IAAF,IAAqBjC,QAA3B;IACAiC,cAAc,IACVA,cAAc,CAAClC,KAAD,EAAQQ,UAAU,CAACyB,WAAD,EAAc,KAAKxB,OAAnB,CAAlB,CADlB;IAEA,KAAK0B,eAAL,GAAuBtC,IAAI,CAACF,eAAe,CAACyC,MAAD,EAAS,aAAT,EAAwB,KAAKd,iBAA7B,CAAhB,EAAiE3B,eAAe,CAACyC,MAAD,EAAS,WAAT,EAAsB,KAAKX,eAA3B,CAAhF,EAA6H9B,eAAe,CAACyC,MAAD,EAAS,eAAT,EAA0B,KAAKX,eAA/B,CAA5I,CAA3B;EACH;;EACDY,cAAc,CAACpC,QAAD,EAAW;IACrB,KAAKA,QAAL,GAAgBA,QAAhB;EACH;;EACD0B,GAAG,GAAG;IACF,KAAKQ,eAAL,IAAwB,KAAKA,eAAL,EAAxB;IACA1C,UAAU,CAACiC,MAAX,CAAkB,KAAKpB,WAAvB;EACH;;AAhFY;;AAkFjB,SAASiB,cAAT,CAAwBhB,IAAxB,EAA8BL,kBAA9B,EAAkD;EAC9C,OAAOA,kBAAkB,GAAG;IAAEa,KAAK,EAAEb,kBAAkB,CAACK,IAAI,CAACQ,KAAN;EAA3B,CAAH,GAA+CR,IAAxE;AACH;;AACD,SAAS+B,aAAT,CAAuBC,CAAvB,EAA0BC,CAA1B,EAA6B;EACzB,OAAO;IAAE3B,CAAC,EAAE0B,CAAC,CAAC1B,CAAF,GAAM2B,CAAC,CAAC3B,CAAb;IAAgBC,CAAC,EAAEyB,CAAC,CAACzB,CAAF,GAAM0B,CAAC,CAAC1B;EAA3B,CAAP;AACH;;AACD,SAASN,UAAT,OAA+BC,OAA/B,EAAwC;EAAA,IAApB;IAAEM;EAAF,CAAoB;EACpC,OAAO;IACHA,KADG;IAEH0B,KAAK,EAAEH,aAAa,CAACvB,KAAD,EAAQ2B,eAAe,CAACjC,OAAD,CAAvB,CAFjB;IAGHG,MAAM,EAAE0B,aAAa,CAACvB,KAAD,EAAQ4B,gBAAgB,CAAClC,OAAD,CAAxB,CAHlB;IAIHmC,QAAQ,EAAEC,WAAW,CAACpC,OAAD,EAAU,GAAV;EAJlB,CAAP;AAMH;;AACD,SAASkC,gBAAT,CAA0BlC,OAA1B,EAAmC;EAC/B,OAAOA,OAAO,CAAC,CAAD,CAAd;AACH;;AACD,SAASiC,eAAT,CAAyBjC,OAAzB,EAAkC;EAC9B,OAAOA,OAAO,CAACA,OAAO,CAACuB,MAAR,GAAiB,CAAlB,CAAd;AACH;;AACD,SAASa,WAAT,CAAqBpC,OAArB,EAA8BqC,SAA9B,EAAyC;EACrC,IAAIrC,OAAO,CAACuB,MAAR,GAAiB,CAArB,EAAwB;IACpB,OAAO;MAAEnB,CAAC,EAAE,CAAL;MAAQC,CAAC,EAAE;IAAX,CAAP;EACH;;EACD,IAAIiC,CAAC,GAAGtC,OAAO,CAACuB,MAAR,GAAiB,CAAzB;EACA,IAAIgB,gBAAgB,GAAG,IAAvB;EACA,MAAMC,SAAS,GAAGP,eAAe,CAACjC,OAAD,CAAjC;;EACA,OAAOsC,CAAC,IAAI,CAAZ,EAAe;IACXC,gBAAgB,GAAGvC,OAAO,CAACsC,CAAD,CAA1B;;IACA,IAAIE,SAAS,CAACjC,SAAV,GAAsBgC,gBAAgB,CAAChC,SAAvC,GACAtB,qBAAqB,CAACoD,SAAD,CADzB,EACsC;MAClC;IACH;;IACDC,CAAC;EACJ;;EACD,IAAI,CAACC,gBAAL,EAAuB;IACnB,OAAO;MAAEnC,CAAC,EAAE,CAAL;MAAQC,CAAC,EAAE;IAAX,CAAP;EACH;;EACD,MAAMoC,IAAI,GAAG,CAACD,SAAS,CAACjC,SAAV,GAAsBgC,gBAAgB,CAAChC,SAAxC,IAAqD,IAAlE;;EACA,IAAIkC,IAAI,KAAK,CAAb,EAAgB;IACZ,OAAO;MAAErC,CAAC,EAAE,CAAL;MAAQC,CAAC,EAAE;IAAX,CAAP;EACH;;EACD,MAAMqC,eAAe,GAAG;IACpBtC,CAAC,EAAE,CAACoC,SAAS,CAACpC,CAAV,GAAcmC,gBAAgB,CAACnC,CAAhC,IAAqCqC,IADpB;IAEpBpC,CAAC,EAAE,CAACmC,SAAS,CAACnC,CAAV,GAAckC,gBAAgB,CAAClC,CAAhC,IAAqCoC;EAFpB,CAAxB;;EAIA,IAAIC,eAAe,CAACtC,CAAhB,KAAsBuC,QAA1B,EAAoC;IAChCD,eAAe,CAACtC,CAAhB,GAAoB,CAApB;EACH;;EACD,IAAIsC,eAAe,CAACrC,CAAhB,KAAsBsC,QAA1B,EAAoC;IAChCD,eAAe,CAACrC,CAAhB,GAAoB,CAApB;EACH;;EACD,OAAOqC,eAAP;AACH;;AAED,SAASrD,UAAT"},"metadata":{},"sourceType":"module"}