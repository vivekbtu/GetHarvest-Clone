{"ast":null,"code":"import _toConsumableArray from \"C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport { env } from '../../utils/process.mjs';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\nimport { warnOnce } from '../../utils/warn-once.mjs';\n\nvar getChildKey = function getChildKey(child) {\n  return child.key || \"\";\n};\n\nfunction updateChildLookup(children, allChildren) {\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\n\n\nvar AnimatePresence = function AnimatePresence(_ref) {\n  var children = _ref.children,\n      custom = _ref.custom,\n      _ref$initial = _ref.initial,\n      initial = _ref$initial === void 0 ? true : _ref$initial,\n      onExitComplete = _ref.onExitComplete,\n      exitBeforeEnter = _ref.exitBeforeEnter,\n      _ref$presenceAffectsL = _ref.presenceAffectsLayout,\n      presenceAffectsLayout = _ref$presenceAffectsL === void 0 ? true : _ref$presenceAffectsL,\n      _ref$mode = _ref.mode,\n      mode = _ref$mode === void 0 ? \"sync\" : _ref$mode;\n\n  // Support deprecated exitBeforeEnter prop\n  if (exitBeforeEnter) {\n    mode = \"wait\";\n    warnOnce(false, \"Replace exitBeforeEnter with mode='wait'\");\n  } // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n\n  var _useForceUpdate = useForceUpdate(),\n      _useForceUpdate2 = _slicedToArray(_useForceUpdate, 1),\n      forceRender = _useForceUpdate2[0];\n\n  var forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n  if (forceRenderLayoutGroup) forceRender = forceRenderLayoutGroup;\n  var isMounted = useIsMounted(); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children);\n  var childrenToRender = filteredChildren;\n  var exiting = new Set(); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = useRef(childrenToRender); // A lookup table to quickly reference components by key\n\n  var allChildren = useRef(new Map()).current; // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  var isInitialRender = useRef(true);\n  useIsomorphicLayoutEffect(function () {\n    isInitialRender.current = false;\n    updateChildLookup(filteredChildren, allChildren);\n    presentChildren.current = childrenToRender;\n  });\n  useUnmountEffect(function () {\n    isInitialRender.current = true;\n    allChildren.clear();\n    exiting.clear();\n  });\n\n  if (isInitialRender.current) {\n    return React.createElement(React.Fragment, null, childrenToRender.map(function (child) {\n      return React.createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  childrenToRender = _toConsumableArray(childrenToRender); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (mode === \"wait\" && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function onExit() {\n      allChildren.delete(key);\n      exiting.delete(key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        if (isMounted.current === false) return;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout,\n      mode: mode\n    }, child);\n  });\n\n  if (env !== \"production\" && mode === \"wait\" && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its mode is set to \\\"wait\\\". This will lead to odd visual behaviour.\");\n  }\n\n  return React.createElement(React.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\n\nexport { AnimatePresence };","map":{"version":3,"names":["React","useContext","useRef","cloneElement","Children","isValidElement","env","useForceUpdate","useIsMounted","PresenceChild","LayoutGroupContext","useIsomorphicLayoutEffect","useUnmountEffect","warnOnce","getChildKey","child","key","updateChildLookup","children","allChildren","forEach","set","onlyElements","filtered","push","AnimatePresence","custom","initial","onExitComplete","exitBeforeEnter","presenceAffectsLayout","mode","forceRender","forceRenderLayoutGroup","isMounted","filteredChildren","childrenToRender","exiting","Set","presentChildren","Map","current","isInitialRender","clear","createElement","Fragment","map","isPresent","undefined","presentKeys","targetKeys","numPresent","length","i","indexOf","add","size","get","insertionIndex","onExit","delete","removeIndex","findIndex","presentChild","splice","has","console","warn"],"sources":["C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"sourcesContent":["import * as React from 'react';\r\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\r\nimport { env } from '../../utils/process.mjs';\r\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\r\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\r\nimport { PresenceChild } from './PresenceChild.mjs';\r\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\r\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\r\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\r\nimport { warnOnce } from '../../utils/warn-once.mjs';\r\n\r\nconst getChildKey = (child) => child.key || \"\";\r\nfunction updateChildLookup(children, allChildren) {\r\n    children.forEach((child) => {\r\n        const key = getChildKey(child);\r\n        allChildren.set(key, child);\r\n    });\r\n}\r\nfunction onlyElements(children) {\r\n    const filtered = [];\r\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\r\n    Children.forEach(children, (child) => {\r\n        if (isValidElement(child))\r\n            filtered.push(child);\r\n    });\r\n    return filtered;\r\n}\r\n/**\r\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\r\n *\r\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\r\n *\r\n * Any `motion` components that have an `exit` property defined will animate out when removed from\r\n * the tree.\r\n *\r\n * ```jsx\r\n * import { motion, AnimatePresence } from 'framer-motion'\r\n *\r\n * export const Items = ({ items }) => (\r\n *   <AnimatePresence>\r\n *     {items.map(item => (\r\n *       <motion.div\r\n *         key={item.id}\r\n *         initial={{ opacity: 0 }}\r\n *         animate={{ opacity: 1 }}\r\n *         exit={{ opacity: 0 }}\r\n *       />\r\n *     ))}\r\n *   </AnimatePresence>\r\n * )\r\n * ```\r\n *\r\n * You can sequence exit animations throughout a tree using variants.\r\n *\r\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\r\n * once all `motion` components have finished animating out. Likewise, any components using\r\n * `usePresence` all need to call `safeToRemove`.\r\n *\r\n * @public\r\n */\r\nconst AnimatePresence = ({ children, custom, initial = true, onExitComplete, exitBeforeEnter, presenceAffectsLayout = true, mode = \"sync\", }) => {\r\n    // Support deprecated exitBeforeEnter prop\r\n    if (exitBeforeEnter) {\r\n        mode = \"wait\";\r\n        warnOnce(false, \"Replace exitBeforeEnter with mode='wait'\");\r\n    }\r\n    // We want to force a re-render once all exiting animations have finished. We\r\n    // either use a local forceRender function, or one from a parent context if it exists.\r\n    let [forceRender] = useForceUpdate();\r\n    const forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\r\n    if (forceRenderLayoutGroup)\r\n        forceRender = forceRenderLayoutGroup;\r\n    const isMounted = useIsMounted();\r\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\r\n    const filteredChildren = onlyElements(children);\r\n    let childrenToRender = filteredChildren;\r\n    const exiting = new Set();\r\n    // Keep a living record of the children we're actually rendering so we\r\n    // can diff to figure out which are entering and exiting\r\n    const presentChildren = useRef(childrenToRender);\r\n    // A lookup table to quickly reference components by key\r\n    const allChildren = useRef(new Map()).current;\r\n    // If this is the initial component render, just deal with logic surrounding whether\r\n    // we play onMount animations or not.\r\n    const isInitialRender = useRef(true);\r\n    useIsomorphicLayoutEffect(() => {\r\n        isInitialRender.current = false;\r\n        updateChildLookup(filteredChildren, allChildren);\r\n        presentChildren.current = childrenToRender;\r\n    });\r\n    useUnmountEffect(() => {\r\n        isInitialRender.current = true;\r\n        allChildren.clear();\r\n        exiting.clear();\r\n    });\r\n    if (isInitialRender.current) {\r\n        return (React.createElement(React.Fragment, null, childrenToRender.map((child) => (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child)))));\r\n    }\r\n    // If this is a subsequent render, deal with entering and exiting children\r\n    childrenToRender = [...childrenToRender];\r\n    // Diff the keys of the currently-present and target children to update our\r\n    // exiting list.\r\n    const presentKeys = presentChildren.current.map(getChildKey);\r\n    const targetKeys = filteredChildren.map(getChildKey);\r\n    // Diff the present children with our target children and mark those that are exiting\r\n    const numPresent = presentKeys.length;\r\n    for (let i = 0; i < numPresent; i++) {\r\n        const key = presentKeys[i];\r\n        if (targetKeys.indexOf(key) === -1) {\r\n            exiting.add(key);\r\n        }\r\n    }\r\n    // If we currently have exiting children, and we're deferring rendering incoming children\r\n    // until after all current children have exiting, empty the childrenToRender array\r\n    if (mode === \"wait\" && exiting.size) {\r\n        childrenToRender = [];\r\n    }\r\n    // Loop through all currently exiting components and clone them to overwrite `animate`\r\n    // with any `exit` prop they might have defined.\r\n    exiting.forEach((key) => {\r\n        // If this component is actually entering again, early return\r\n        if (targetKeys.indexOf(key) !== -1)\r\n            return;\r\n        const child = allChildren.get(key);\r\n        if (!child)\r\n            return;\r\n        const insertionIndex = presentKeys.indexOf(key);\r\n        const onExit = () => {\r\n            allChildren.delete(key);\r\n            exiting.delete(key);\r\n            // Remove this child from the present children\r\n            const removeIndex = presentChildren.current.findIndex((presentChild) => presentChild.key === key);\r\n            presentChildren.current.splice(removeIndex, 1);\r\n            // Defer re-rendering until all exiting children have indeed left\r\n            if (!exiting.size) {\r\n                presentChildren.current = filteredChildren;\r\n                if (isMounted.current === false)\r\n                    return;\r\n                forceRender();\r\n                onExitComplete && onExitComplete();\r\n            }\r\n        };\r\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\r\n    });\r\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\r\n    // the same tree between renders\r\n    childrenToRender = childrenToRender.map((child) => {\r\n        const key = child.key;\r\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout, mode: mode }, child));\r\n    });\r\n    if (env !== \"production\" &&\r\n        mode === \"wait\" &&\r\n        childrenToRender.length > 1) {\r\n        console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\r\n    }\r\n    return (React.createElement(React.Fragment, null, exiting.size\r\n        ? childrenToRender\r\n        : childrenToRender.map((child) => cloneElement(child))));\r\n};\r\n\r\nexport { AnimatePresence };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}