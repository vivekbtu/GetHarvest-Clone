{"ast":null,"code":"import { useContext, useRef, useMemo } from 'react';\nimport { animate } from 'popmotion';\nimport { isMotionValue } from './utils/is-motion-value.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\nimport { useOnChange } from './use-on-change.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\n\nfunction useSpring(source) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    isStatic\n  } = useContext(MotionConfigContext);\n  const activeSpringAnimation = useRef(null);\n  const value = useMotionValue(isMotionValue(source) ? source.get() : source);\n  useMemo(() => {\n    return value.attach((v, set) => {\n      /**\n       * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n       * at that level, but this will work for now\n       */\n      if (isStatic) return set(v);\n\n      if (activeSpringAnimation.current) {\n        activeSpringAnimation.current.stop();\n      }\n\n      activeSpringAnimation.current = animate(Object.assign(Object.assign({\n        from: value.get(),\n        to: v,\n        velocity: value.getVelocity()\n      }, config), {\n        onUpdate: set\n      }));\n      return value.get();\n    });\n  }, [JSON.stringify(config)]);\n  useOnChange(source, v => value.set(parseFloat(v)));\n  return value;\n}\n\nexport { useSpring };","map":{"version":3,"names":["useContext","useRef","useMemo","animate","isMotionValue","useMotionValue","useOnChange","MotionConfigContext","useSpring","source","config","isStatic","activeSpringAnimation","value","get","attach","v","set","current","stop","Object","assign","from","to","velocity","getVelocity","onUpdate","JSON","stringify","parseFloat"],"sources":["C:/Users/bittu/Desktop/React-Unit4Project/premium-grade-140/node_modules/framer-motion/dist/es/value/use-spring.mjs"],"sourcesContent":["import { useContext, useRef, useMemo } from 'react';\nimport { animate } from 'popmotion';\nimport { isMotionValue } from './utils/is-motion-value.mjs';\nimport { useMotionValue } from './use-motion-value.mjs';\nimport { useOnChange } from './use-on-change.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config = {}) {\n    const { isStatic } = useContext(MotionConfigContext);\n    const activeSpringAnimation = useRef(null);\n    const value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    useMemo(() => {\n        return value.attach((v, set) => {\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */\n            if (isStatic)\n                return set(v);\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = animate(Object.assign(Object.assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));\n            return value.get();\n        });\n    }, [JSON.stringify(config)]);\n    useOnChange(source, (v) => value.set(parseFloat(v)));\n    return value;\n}\n\nexport { useSpring };\n"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,MAArB,EAA6BC,OAA7B,QAA4C,OAA5C;AACA,SAASC,OAAT,QAAwB,WAAxB;AACA,SAASC,aAAT,QAA8B,6BAA9B;AACA,SAASC,cAAT,QAA+B,wBAA/B;AACA,SAASC,WAAT,QAA4B,qBAA5B;AACA,SAASC,mBAAT,QAAoC,oCAApC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,SAAT,CAAmBC,MAAnB,EAAwC;EAAA,IAAbC,MAAa,uEAAJ,EAAI;EACpC,MAAM;IAAEC;EAAF,IAAeX,UAAU,CAACO,mBAAD,CAA/B;EACA,MAAMK,qBAAqB,GAAGX,MAAM,CAAC,IAAD,CAApC;EACA,MAAMY,KAAK,GAAGR,cAAc,CAACD,aAAa,CAACK,MAAD,CAAb,GAAwBA,MAAM,CAACK,GAAP,EAAxB,GAAuCL,MAAxC,CAA5B;EACAP,OAAO,CAAC,MAAM;IACV,OAAOW,KAAK,CAACE,MAAN,CAAa,CAACC,CAAD,EAAIC,GAAJ,KAAY;MAC5B;AACZ;AACA;AACA;MACY,IAAIN,QAAJ,EACI,OAAOM,GAAG,CAACD,CAAD,CAAV;;MACJ,IAAIJ,qBAAqB,CAACM,OAA1B,EAAmC;QAC/BN,qBAAqB,CAACM,OAAtB,CAA8BC,IAA9B;MACH;;MACDP,qBAAqB,CAACM,OAAtB,GAAgCf,OAAO,CAACiB,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc;QAAEC,IAAI,EAAET,KAAK,CAACC,GAAN,EAAR;QAAqBS,EAAE,EAAEP,CAAzB;QAA4BQ,QAAQ,EAAEX,KAAK,CAACY,WAAN;MAAtC,CAAd,EAA2Ef,MAA3E,CAAd,EAAkG;QAAEgB,QAAQ,EAAET;MAAZ,CAAlG,CAAD,CAAvC;MACA,OAAOJ,KAAK,CAACC,GAAN,EAAP;IACH,CAZM,CAAP;EAaH,CAdM,EAcJ,CAACa,IAAI,CAACC,SAAL,CAAelB,MAAf,CAAD,CAdI,CAAP;EAeAJ,WAAW,CAACG,MAAD,EAAUO,CAAD,IAAOH,KAAK,CAACI,GAAN,CAAUY,UAAU,CAACb,CAAD,CAApB,CAAhB,CAAX;EACA,OAAOH,KAAP;AACH;;AAED,SAASL,SAAT"},"metadata":{},"sourceType":"module"}