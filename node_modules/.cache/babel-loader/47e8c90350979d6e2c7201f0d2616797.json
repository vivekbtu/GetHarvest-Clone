{"ast":null,"code":"import { __rest } from 'tslib';\nimport { visualElement } from '../index.mjs';\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\nimport { isTransformProp } from './utils/transform.mjs';\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\nimport { renderHTML } from './utils/render.mjs';\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\n\nfunction getComputedStyle(element) {\n  return window.getComputedStyle(element);\n}\n\nconst htmlConfig = {\n  treeType: \"dom\",\n\n  readValueFromInstance(domElement, key) {\n    if (isTransformProp(key)) {\n      const defaultType = getDefaultValueType(key);\n      return defaultType ? defaultType.default || 0 : 0;\n    } else {\n      const computedStyle = getComputedStyle(domElement);\n      const value = (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;\n      return typeof value === \"string\" ? value.trim() : value;\n    }\n  },\n\n  sortNodePosition(a, b) {\n    /**\r\n     * compareDocumentPosition returns a bitmask, by using the bitwise &\r\n     * we're returning true if 2 in that bitmask is set to true. 2 is set\r\n     * to true if b preceeds a.\r\n     */\n    return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n  },\n\n  getBaseTarget(props, key) {\n    var _a;\n\n    return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n  },\n\n  measureViewportBox(element, _ref) {\n    let {\n      transformPagePoint\n    } = _ref;\n    return measureViewportBox(element, transformPagePoint);\n  },\n\n  /**\r\n   * Reset the transform on the current Element. This is called as part\r\n   * of a batched process across the entire layout tree. To remove this write\r\n   * cycle it'd be interesting to see if it's possible to \"undo\" all the current\r\n   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\r\n   * works\r\n   */\n  resetTransform(element, domElement, props) {\n    const {\n      transformTemplate\n    } = props;\n    domElement.style.transform = transformTemplate ? transformTemplate({}, \"\") : \"none\"; // Ensure that whatever happens next, we restore our transform on the next frame\n\n    element.scheduleRender();\n  },\n\n  restoreTransform(instance, mutableState) {\n    instance.style.transform = mutableState.style.transform;\n  },\n\n  removeValueFromRenderState(key, _ref2) {\n    let {\n      vars,\n      style\n    } = _ref2;\n    delete vars[key];\n    delete style[key];\n  },\n\n  /**\r\n   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\r\n   * can be animated by Motion.\r\n   */\n  makeTargetAnimatable(element, _a, _b, isMounted) {\n    var {\n      transition,\n      transitionEnd\n    } = _a,\n        target = __rest(_a, [\"transition\", \"transitionEnd\"]);\n\n    var transformValues = _b.transformValues;\n\n    if (isMounted === void 0) {\n      isMounted = true;\n    }\n\n    let origin = getOrigin(target, transition || {}, element);\n    /**\r\n     * If Framer has provided a function to convert `Color` etc value types, convert them\r\n     */\n\n    if (transformValues) {\n      if (transitionEnd) transitionEnd = transformValues(transitionEnd);\n      if (target) target = transformValues(target);\n      if (origin) origin = transformValues(origin);\n    }\n\n    if (isMounted) {\n      checkTargetForNewValues(element, target, origin);\n      const parsed = parseDomVariant(element, target, origin, transitionEnd);\n      transitionEnd = parsed.transitionEnd;\n      target = parsed.target;\n    }\n\n    return Object.assign({\n      transition,\n      transitionEnd\n    }, target);\n  },\n\n  scrapeMotionValuesFromProps,\n\n  build(element, renderState, latestValues, options, props) {\n    if (element.isVisible !== undefined) {\n      renderState.style.visibility = element.isVisible ? \"visible\" : \"hidden\";\n    }\n\n    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n  },\n\n  render: renderHTML\n};\nconst htmlVisualElement = visualElement(htmlConfig);\nexport { getComputedStyle, htmlConfig, htmlVisualElement };","map":{"version":3,"names":["__rest","visualElement","getOrigin","checkTargetForNewValues","buildHTMLStyles","isCSSVariable","parseDomVariant","isTransformProp","scrapeMotionValuesFromProps","renderHTML","getDefaultValueType","measureViewportBox","getComputedStyle","element","window","htmlConfig","treeType","readValueFromInstance","domElement","key","defaultType","default","computedStyle","value","getPropertyValue","trim","sortNodePosition","a","b","compareDocumentPosition","getBaseTarget","props","_a","style","transformPagePoint","resetTransform","transformTemplate","transform","scheduleRender","restoreTransform","instance","mutableState","removeValueFromRenderState","vars","makeTargetAnimatable","_b","isMounted","transition","transitionEnd","target","transformValues","origin","parsed","Object","assign","build","renderState","latestValues","options","isVisible","undefined","visibility","render","htmlVisualElement"],"sources":["C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/framer-motion/dist/es/render/html/visual-element.mjs"],"sourcesContent":["import { __rest } from 'tslib';\r\nimport { visualElement } from '../index.mjs';\r\nimport { getOrigin, checkTargetForNewValues } from '../utils/setters.mjs';\r\nimport { buildHTMLStyles } from './utils/build-styles.mjs';\r\nimport { isCSSVariable } from '../dom/utils/is-css-variable.mjs';\r\nimport { parseDomVariant } from '../dom/utils/parse-dom-variant.mjs';\r\nimport { isTransformProp } from './utils/transform.mjs';\r\nimport { scrapeMotionValuesFromProps } from './utils/scrape-motion-values.mjs';\r\nimport { renderHTML } from './utils/render.mjs';\r\nimport { getDefaultValueType } from '../dom/value-types/defaults.mjs';\r\nimport { measureViewportBox } from '../../projection/utils/measure.mjs';\r\n\r\nfunction getComputedStyle(element) {\r\n    return window.getComputedStyle(element);\r\n}\r\nconst htmlConfig = {\r\n    treeType: \"dom\",\r\n    readValueFromInstance(domElement, key) {\r\n        if (isTransformProp(key)) {\r\n            const defaultType = getDefaultValueType(key);\r\n            return defaultType ? defaultType.default || 0 : 0;\r\n        }\r\n        else {\r\n            const computedStyle = getComputedStyle(domElement);\r\n            const value = (isCSSVariable(key)\r\n                ? computedStyle.getPropertyValue(key)\r\n                : computedStyle[key]) || 0;\r\n            return typeof value === \"string\" ? value.trim() : value;\r\n        }\r\n    },\r\n    sortNodePosition(a, b) {\r\n        /**\r\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\r\n         * we're returning true if 2 in that bitmask is set to true. 2 is set\r\n         * to true if b preceeds a.\r\n         */\r\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\r\n    },\r\n    getBaseTarget(props, key) {\r\n        var _a;\r\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\r\n    },\r\n    measureViewportBox(element, { transformPagePoint }) {\r\n        return measureViewportBox(element, transformPagePoint);\r\n    },\r\n    /**\r\n     * Reset the transform on the current Element. This is called as part\r\n     * of a batched process across the entire layout tree. To remove this write\r\n     * cycle it'd be interesting to see if it's possible to \"undo\" all the current\r\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\r\n     * works\r\n     */\r\n    resetTransform(element, domElement, props) {\r\n        const { transformTemplate } = props;\r\n        domElement.style.transform = transformTemplate\r\n            ? transformTemplate({}, \"\")\r\n            : \"none\";\r\n        // Ensure that whatever happens next, we restore our transform on the next frame\r\n        element.scheduleRender();\r\n    },\r\n    restoreTransform(instance, mutableState) {\r\n        instance.style.transform = mutableState.style.transform;\r\n    },\r\n    removeValueFromRenderState(key, { vars, style }) {\r\n        delete vars[key];\r\n        delete style[key];\r\n    },\r\n    /**\r\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\r\n     * can be animated by Motion.\r\n     */\r\n    makeTargetAnimatable(element, _a, _b, isMounted) {\r\n        var { transition, transitionEnd } = _a, target = __rest(_a, [\"transition\", \"transitionEnd\"]);\r\n        var transformValues = _b.transformValues;\r\n        if (isMounted === void 0) { isMounted = true; }\r\n        let origin = getOrigin(target, transition || {}, element);\r\n        /**\r\n         * If Framer has provided a function to convert `Color` etc value types, convert them\r\n         */\r\n        if (transformValues) {\r\n            if (transitionEnd)\r\n                transitionEnd = transformValues(transitionEnd);\r\n            if (target)\r\n                target = transformValues(target);\r\n            if (origin)\r\n                origin = transformValues(origin);\r\n        }\r\n        if (isMounted) {\r\n            checkTargetForNewValues(element, target, origin);\r\n            const parsed = parseDomVariant(element, target, origin, transitionEnd);\r\n            transitionEnd = parsed.transitionEnd;\r\n            target = parsed.target;\r\n        }\r\n        return Object.assign({ transition,\r\n            transitionEnd }, target);\r\n    },\r\n    scrapeMotionValuesFromProps,\r\n    build(element, renderState, latestValues, options, props) {\r\n        if (element.isVisible !== undefined) {\r\n            renderState.style.visibility = element.isVisible\r\n                ? \"visible\"\r\n                : \"hidden\";\r\n        }\r\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\r\n    },\r\n    render: renderHTML,\r\n};\r\nconst htmlVisualElement = visualElement(htmlConfig);\r\n\r\nexport { getComputedStyle, htmlConfig, htmlVisualElement };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}