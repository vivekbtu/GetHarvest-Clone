{"ast":null,"code":"import _slicedToArray from \"C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useContext, useState, useEffect } from 'react';\nimport { motionValue } from './index.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\n\nfunction useMotionValue(initial) {\n  var value = useConstant(function () {\n    return motionValue(initial);\n  });\n  /**\r\n   * If this motion value is being used in static mode, like on\r\n   * the Framer canvas, force components to rerender when the motion\r\n   * value is updated.\r\n   */\n\n  var _useContext = useContext(MotionConfigContext),\n      isStatic = _useContext.isStatic;\n\n  if (isStatic) {\n    var _useState = useState(initial),\n        _useState2 = _slicedToArray(_useState, 2),\n        setLatest = _useState2[1];\n\n    useEffect(function () {\n      return value.onChange(setLatest);\n    }, []);\n  }\n\n  return value;\n}\n\nexport { useMotionValue };","map":{"version":3,"names":["useContext","useState","useEffect","motionValue","MotionConfigContext","useConstant","useMotionValue","initial","value","isStatic","setLatest","onChange"],"sources":["C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/framer-motion/dist/es/value/use-motion-value.mjs"],"sourcesContent":["import { useContext, useState, useEffect } from 'react';\r\nimport { motionValue } from './index.mjs';\r\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\r\nimport { useConstant } from '../utils/use-constant.mjs';\r\n\r\n/**\r\n * Creates a `MotionValue` to track the state and velocity of a value.\r\n *\r\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\r\n *\r\n * ```jsx\r\n * export const MyComponent = () => {\r\n *   const scale = useMotionValue(1)\r\n *\r\n *   return <motion.div style={{ scale }} />\r\n * }\r\n * ```\r\n *\r\n * @param initial - The initial state.\r\n *\r\n * @public\r\n */\r\nfunction useMotionValue(initial) {\r\n    const value = useConstant(() => motionValue(initial));\r\n    /**\r\n     * If this motion value is being used in static mode, like on\r\n     * the Framer canvas, force components to rerender when the motion\r\n     * value is updated.\r\n     */\r\n    const { isStatic } = useContext(MotionConfigContext);\r\n    if (isStatic) {\r\n        const [, setLatest] = useState(initial);\r\n        useEffect(() => value.onChange(setLatest), []);\r\n    }\r\n    return value;\r\n}\r\n\r\nexport { useMotionValue };\r\n"],"mappings":";AAAA,SAASA,UAAT,EAAqBC,QAArB,EAA+BC,SAA/B,QAAgD,OAAhD;AACA,SAASC,WAAT,QAA4B,aAA5B;AACA,SAASC,mBAAT,QAAoC,oCAApC;AACA,SAASC,WAAT,QAA4B,2BAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBC,OAAxB,EAAiC;EAC7B,IAAMC,KAAK,GAAGH,WAAW,CAAC;IAAA,OAAMF,WAAW,CAACI,OAAD,CAAjB;EAAA,CAAD,CAAzB;EACA;AACJ;AACA;AACA;AACA;;EACI,kBAAqBP,UAAU,CAACI,mBAAD,CAA/B;EAAA,IAAQK,QAAR,eAAQA,QAAR;;EACA,IAAIA,QAAJ,EAAc;IACV,gBAAsBR,QAAQ,CAACM,OAAD,CAA9B;IAAA;IAAA,IAASG,SAAT;;IACAR,SAAS,CAAC;MAAA,OAAMM,KAAK,CAACG,QAAN,CAAeD,SAAf,CAAN;IAAA,CAAD,EAAkC,EAAlC,CAAT;EACH;;EACD,OAAOF,KAAP;AACH;;AAED,SAASF,cAAT"},"metadata":{},"sourceType":"module"}