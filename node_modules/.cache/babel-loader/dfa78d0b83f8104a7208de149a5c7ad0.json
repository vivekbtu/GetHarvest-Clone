{"ast":null,"code":"import { __rest } from 'tslib';\nimport { startAnimation } from '../../animation/utils/transitions.mjs';\nimport { setTarget } from './setters.mjs';\nimport { resolveVariant } from './variants.mjs';\nimport { isTransformProp } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\n\nfunction animateVisualElement(visualElement, definition) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  visualElement.notifyAnimationStart(definition);\n  let animation;\n\n  if (Array.isArray(definition)) {\n    const animations = definition.map(variant => animateVariant(visualElement, variant, options));\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    const resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n\n  return animation.then(() => visualElement.notifyAnimationComplete(definition));\n}\n\nfunction animateVariant(visualElement, variant) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  const resolved = resolveVariant(visualElement, variant, options.custom);\n  let {\n    transition = visualElement.getDefaultTransition() || {}\n  } = resolved || {};\n\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\r\n   * If we have a variant, create a callback that runs it as an animation.\r\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n   */\n\n\n  const getAnimation = resolved ? () => animateTarget(visualElement, resolved, options) : () => Promise.resolve();\n  /**\r\n   * If we have children, create a callback that runs all their animations.\r\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n   */\n\n  const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function () {\n    let forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const {\n      delayChildren = 0,\n      staggerChildren,\n      staggerDirection\n    } = transition;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  /**\r\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\r\n   * this animation or all children animations before playing the other.\r\n   */\n\n  const {\n    when\n  } = transition;\n\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\r\n * @internal\r\n */\n\n\nfunction animateTarget(visualElement, definition) {\n  let {\n    delay = 0,\n    transitionOverride,\n    type\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  let _b = visualElement.makeTargetAnimatable(definition),\n      {\n    transition = visualElement.getDefaultTransition(),\n    transitionEnd\n  } = _b,\n      target = __rest(_b, [\"transition\", \"transitionEnd\"]);\n\n  const willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride) transition = transitionOverride;\n  const animations = [];\n  const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n\n  for (const key in target) {\n    const value = visualElement.getValue(key);\n    const valueTarget = target[key];\n\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      continue;\n    }\n\n    let valueTransition = Object.assign({\n      delay\n    }, transition);\n    /**\r\n     * Make animation instant if this is a transform prop and we should reduce motion.\r\n     */\n\n    if (visualElement.shouldReduceMotion && isTransformProp(key)) {\n      valueTransition = Object.assign(Object.assign({}, valueTransition), {\n        type: false,\n        delay: 0\n      });\n    }\n\n    let animation = startAnimation(key, value, valueTarget, valueTransition);\n\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(() => willChange.remove(key));\n    }\n\n    animations.push(animation);\n  }\n\n  return Promise.all(animations).then(() => {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\n\nfunction animateChildren(visualElement, variant) {\n  let delayChildren = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let staggerChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let staggerDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  let options = arguments.length > 5 ? arguments[5] : undefined;\n  const animations = [];\n  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  const generateStaggerDuration = staggerDirection === 1 ? function () {\n    let i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return i * staggerChildren;\n  } : function () {\n    let i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {\n    animations.push(animateVariant(child, variant, Object.assign(Object.assign({}, options), {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(() => child.notifyAnimationComplete(variant)));\n  });\n  return Promise.all(animations);\n}\n\nfunction stopAnimation(visualElement) {\n  visualElement.forEachValue(value => value.stop());\n}\n\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\n\n\nfunction shouldBlockAnimation(_ref, key) {\n  let {\n    protectedKeys,\n    needsAnimating\n  } = _ref;\n  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };","map":{"version":3,"names":["__rest","startAnimation","setTarget","resolveVariant","isTransformProp","isWillChangeMotionValue","animateVisualElement","visualElement","definition","options","notifyAnimationStart","animation","Array","isArray","animations","map","variant","animateVariant","Promise","all","resolvedDefinition","custom","animateTarget","then","notifyAnimationComplete","_a","resolved","transition","getDefaultTransition","transitionOverride","getAnimation","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","delay","type","_b","makeTargetAnimatable","transitionEnd","target","willChange","getValue","animationTypeState","animationState","getState","key","value","valueTarget","undefined","shouldBlockAnimation","valueTransition","Object","assign","shouldReduceMotion","add","remove","push","maxStaggerDuration","generateStaggerDuration","i","from","sort","sortByTreeOrder","forEach","child","stopAnimation","forEachValue","stop","a","b","sortNodePosition","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty"],"sources":["C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/framer-motion/dist/es/render/utils/animation.mjs"],"sourcesContent":["import { __rest } from 'tslib';\r\nimport { startAnimation } from '../../animation/utils/transitions.mjs';\r\nimport { setTarget } from './setters.mjs';\r\nimport { resolveVariant } from './variants.mjs';\r\nimport { isTransformProp } from '../html/utils/transform.mjs';\r\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\r\n\r\nfunction animateVisualElement(visualElement, definition, options = {}) {\r\n    visualElement.notifyAnimationStart(definition);\r\n    let animation;\r\n    if (Array.isArray(definition)) {\r\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\r\n        animation = Promise.all(animations);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        animation = animateVariant(visualElement, definition, options);\r\n    }\r\n    else {\r\n        const resolvedDefinition = typeof definition === \"function\"\r\n            ? resolveVariant(visualElement, definition, options.custom)\r\n            : definition;\r\n        animation = animateTarget(visualElement, resolvedDefinition, options);\r\n    }\r\n    return animation.then(() => visualElement.notifyAnimationComplete(definition));\r\n}\r\nfunction animateVariant(visualElement, variant, options = {}) {\r\n    var _a;\r\n    const resolved = resolveVariant(visualElement, variant, options.custom);\r\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\r\n    if (options.transitionOverride) {\r\n        transition = options.transitionOverride;\r\n    }\r\n    /**\r\n     * If we have a variant, create a callback that runs it as an animation.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getAnimation = resolved\r\n        ? () => animateTarget(visualElement, resolved, options)\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If we have children, create a callback that runs all their animations.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\r\n        ? (forwardDelay = 0) => {\r\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\r\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\r\n        }\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\r\n     * this animation or all children animations before playing the other.\r\n     */\r\n    const { when } = transition;\r\n    if (when) {\r\n        const [first, last] = when === \"beforeChildren\"\r\n            ? [getAnimation, getChildAnimations]\r\n            : [getChildAnimations, getAnimation];\r\n        return first().then(last);\r\n    }\r\n    else {\r\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction animateTarget(visualElement, definition, { delay = 0, transitionOverride, type } = {}) {\r\n    var _a;\r\n    let _b = visualElement.makeTargetAnimatable(definition), { transition = visualElement.getDefaultTransition(), transitionEnd } = _b, target = __rest(_b, [\"transition\", \"transitionEnd\"]);\r\n    const willChange = visualElement.getValue(\"willChange\");\r\n    if (transitionOverride)\r\n        transition = transitionOverride;\r\n    const animations = [];\r\n    const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\r\n    for (const key in target) {\r\n        const value = visualElement.getValue(key);\r\n        const valueTarget = target[key];\r\n        if (!value ||\r\n            valueTarget === undefined ||\r\n            (animationTypeState &&\r\n                shouldBlockAnimation(animationTypeState, key))) {\r\n            continue;\r\n        }\r\n        let valueTransition = Object.assign({ delay }, transition);\r\n        /**\r\n         * Make animation instant if this is a transform prop and we should reduce motion.\r\n         */\r\n        if (visualElement.shouldReduceMotion && isTransformProp(key)) {\r\n            valueTransition = Object.assign(Object.assign({}, valueTransition), { type: false, delay: 0 });\r\n        }\r\n        let animation = startAnimation(key, value, valueTarget, valueTransition);\r\n        if (isWillChangeMotionValue(willChange)) {\r\n            willChange.add(key);\r\n            animation = animation.then(() => willChange.remove(key));\r\n        }\r\n        animations.push(animation);\r\n    }\r\n    return Promise.all(animations).then(() => {\r\n        transitionEnd && setTarget(visualElement, transitionEnd);\r\n    });\r\n}\r\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\r\n    const animations = [];\r\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\r\n    const generateStaggerDuration = staggerDirection === 1\r\n        ? (i = 0) => i * staggerChildren\r\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\r\n    Array.from(visualElement.variantChildren)\r\n        .sort(sortByTreeOrder)\r\n        .forEach((child, i) => {\r\n        animations.push(animateVariant(child, variant, Object.assign(Object.assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(() => child.notifyAnimationComplete(variant)));\r\n    });\r\n    return Promise.all(animations);\r\n}\r\nfunction stopAnimation(visualElement) {\r\n    visualElement.forEachValue((value) => value.stop());\r\n}\r\nfunction sortByTreeOrder(a, b) {\r\n    return a.sortNodePosition(b);\r\n}\r\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\r\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\r\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\r\n    needsAnimating[key] = false;\r\n    return shouldBlock;\r\n}\r\n\r\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}