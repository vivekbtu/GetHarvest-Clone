{"ast":null,"code":"import { mix, progress, clamp } from 'popmotion';\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\n\nfunction applyConstraints(point, _ref, elastic) {\n  let {\n    min,\n    max\n  } = _ref;\n\n  if (min !== undefined && point < min) {\n    // If we have a min point defined, and this is outside of that, constrain\n    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\n  } else if (max !== undefined && point > max) {\n    // If we have a max point defined, and this is outside of that, constrain\n    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\n  }\n\n  return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\n\n\nfunction calcRelativeAxisConstraints(axis, min, max) {\n  return {\n    min: min !== undefined ? axis.min + min : undefined,\n    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined\n  };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\n\n\nfunction calcRelativeConstraints(layoutBox, _ref2) {\n  let {\n    top,\n    left,\n    bottom,\n    right\n  } = _ref2;\n  return {\n    x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\n\n\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n  let min = constraintsAxis.min - layoutAxis.min;\n  let max = constraintsAxis.max - layoutAxis.max; // If the constraints axis is actually smaller than the layout axis then we can\n  // flip the constraints\n\n  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {\n    [min, max] = [max, min];\n  }\n\n  return {\n    min,\n    max\n  };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\n\n\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n  return {\n    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)\n  };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\n\n\nfunction calcOrigin(source, target) {\n  let origin = 0.5;\n  const sourceLength = calcLength(source);\n  const targetLength = calcLength(target);\n\n  if (targetLength > sourceLength) {\n    origin = progress(target.min, target.max - sourceLength, source.min);\n  } else if (sourceLength > targetLength) {\n    origin = progress(source.min, source.max - targetLength, target.min);\n  }\n\n  return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\n\n\nfunction rebaseAxisConstraints(layout, constraints) {\n  const relativeConstraints = {};\n\n  if (constraints.min !== undefined) {\n    relativeConstraints.min = constraints.min - layout.min;\n  }\n\n  if (constraints.max !== undefined) {\n    relativeConstraints.max = constraints.max - layout.min;\n  }\n\n  return relativeConstraints;\n}\n\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\n\nfunction resolveDragElastic() {\n  let dragElastic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultElastic;\n\n  if (dragElastic === false) {\n    dragElastic = 0;\n  } else if (dragElastic === true) {\n    dragElastic = defaultElastic;\n  }\n\n  return {\n    x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n    y: resolveAxisElastic(dragElastic, \"top\", \"bottom\")\n  };\n}\n\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n  return {\n    min: resolvePointElastic(dragElastic, minLabel),\n    max: resolvePointElastic(dragElastic, maxLabel)\n  };\n}\n\nfunction resolvePointElastic(dragElastic, label) {\n  var _a;\n\n  return typeof dragElastic === \"number\" ? dragElastic : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };","map":{"version":3,"names":["mix","progress","clamp","calcLength","applyConstraints","point","elastic","min","max","undefined","Math","calcRelativeAxisConstraints","axis","calcRelativeConstraints","layoutBox","top","left","bottom","right","x","y","calcViewportAxisConstraints","layoutAxis","constraintsAxis","calcViewportConstraints","constraintsBox","calcOrigin","source","target","origin","sourceLength","targetLength","rebaseAxisConstraints","layout","constraints","relativeConstraints","defaultElastic","resolveDragElastic","dragElastic","resolveAxisElastic","minLabel","maxLabel","resolvePointElastic","label","_a"],"sources":["C:/Users/bittu/Desktop/React-Unit4Project/premium-grade-140/node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs"],"sourcesContent":["import { mix, progress, clamp } from 'popmotion';\nimport { calcLength } from '../../../projection/geometry/delta-calc.mjs';\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, { min, max }, elastic) {\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    let min = constraintsAxis.min - layoutAxis.min;\n    let max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        [min, max] = [max, min];\n    }\n    return { min, max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction calcOrigin(source, target) {\n    let origin = 0.5;\n    const sourceLength = calcLength(source);\n    const targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    const relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nconst defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic = defaultElastic) {\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, \"left\", \"right\"),\n        y: resolveAxisElastic(dragElastic, \"top\", \"bottom\"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === \"number\"\n        ? dragElastic\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\nexport { applyConstraints, calcOrigin, calcRelativeAxisConstraints, calcRelativeConstraints, calcViewportAxisConstraints, calcViewportConstraints, defaultElastic, rebaseAxisConstraints, resolveAxisElastic, resolveDragElastic, resolvePointElastic };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}