{"ast":null,"code":"import * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { useFeatures } from './features/use-features.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { loadFeatures, featureDefinitions } from './features/definitions.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { useProjectionId } from '../projection/node/id.mjs';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { useProjection } from './features/use-projection.mjs';\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n */\n\nfunction createMotionComponent(_ref) {\n  var preloadedFeatures = _ref.preloadedFeatures,\n      createVisualElement = _ref.createVisualElement,\n      projectionNodeConstructor = _ref.projectionNodeConstructor,\n      useRender = _ref.useRender,\n      useVisualState = _ref.useVisualState,\n      Component = _ref.Component;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n\n  function MotionComponent(props, externalRef) {\n    var layoutId = useLayoutId(props);\n    props = Object.assign(Object.assign({}, props), {\n      layoutId: layoutId\n    });\n    /**\r\n     * If we're rendering in a static environment, we only visually update the component\r\n     * as a result of a React-rerender rather than interactions or animations. This\r\n     * means we don't need to load additional memory structures like VisualElement,\r\n     * or any gesture/animation features.\r\n     */\n\n    var config = useContext(MotionConfigContext);\n    var features = null;\n    var context = useCreateMotionContext(props);\n    /**\r\n     * Create a unique projection ID for this component. If a new component is added\r\n     * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\r\n     * us to measure it as soon as any layout effect flushes pending layout animations.\r\n     *\r\n     * Performance note: It'd be better not to have to search the DOM for these elements.\r\n     * For newly-entering components it could be enough to only correct treeScale, in which\r\n     * case we could mount in a scale-correction mode. This wouldn't be enough for\r\n     * shared element transitions however. Perhaps for those we could revert to a root node\r\n     * that gets forceRendered and layout animations are triggered on its layout effect.\r\n     */\n\n    var projectionId = config.isStatic ? undefined : useProjectionId();\n    /**\r\n     *\r\n     */\n\n    var visualState = useVisualState(props, config.isStatic);\n\n    if (!config.isStatic && isBrowser) {\n      /**\r\n       * Create a VisualElement for this component. A VisualElement provides a common\r\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n       * providing a way of rendering to these APIs outside of the React render loop\r\n       * for more performant animations and interactions\r\n       */\n      context.visualElement = useVisualElement(Component, visualState, Object.assign(Object.assign({}, config), props), createVisualElement);\n      useProjection(projectionId, props, context.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);\n      /**\r\n       * Load Motion gesture and animation features. These are rendered as renderless\r\n       * components so each feature can optionally make use of React lifecycle methods.\r\n       */\n\n      features = useFeatures(props, context.visualElement, preloadedFeatures);\n    }\n    /**\r\n     * The mount order and hierarchy is specific to ensure our element ref\r\n     * is hydrated by the time features fire their effects.\r\n     */\n\n\n    return React.createElement(VisualElementHandler, {\n      visualElement: context.visualElement,\n      props: Object.assign(Object.assign({}, config), props)\n    }, features, React.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement)));\n  }\n\n  return forwardRef(MotionComponent);\n}\n\nfunction useLayoutId(_ref2) {\n  var layoutId = _ref2.layoutId;\n\n  var _a;\n\n  var layoutGroupId = (_a = useContext(LayoutGroupContext)) === null || _a === void 0 ? void 0 : _a.id;\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\nexport { createMotionComponent };","map":{"version":3,"names":["React","forwardRef","useContext","useFeatures","MotionConfigContext","MotionContext","useVisualElement","useMotionRef","useCreateMotionContext","loadFeatures","featureDefinitions","isBrowser","useProjectionId","LayoutGroupContext","useProjection","VisualElementHandler","createMotionComponent","preloadedFeatures","createVisualElement","projectionNodeConstructor","useRender","useVisualState","Component","MotionComponent","props","externalRef","layoutId","useLayoutId","Object","assign","config","features","context","projectionId","isStatic","undefined","visualState","visualElement","createElement","Provider","value","_a","layoutGroupId","id"],"sources":["C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/framer-motion/dist/es/motion/index.mjs"],"sourcesContent":["import * as React from 'react';\r\nimport { forwardRef, useContext } from 'react';\r\nimport { useFeatures } from './features/use-features.mjs';\r\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\r\nimport { MotionContext } from '../context/MotionContext/index.mjs';\r\nimport { useVisualElement } from './utils/use-visual-element.mjs';\r\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\r\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\r\nimport { loadFeatures, featureDefinitions } from './features/definitions.mjs';\r\nimport { isBrowser } from '../utils/is-browser.mjs';\r\nimport { useProjectionId } from '../projection/node/id.mjs';\r\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\r\nimport { useProjection } from './features/use-projection.mjs';\r\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\r\n\r\n/**\r\n * Create a `motion` component.\r\n *\r\n * This function accepts a Component argument, which can be either a string (ie \"div\"\r\n * for `motion.div`), or an actual React component.\r\n *\r\n * Alongside this is a config option which provides a way of rendering the provided\r\n * component \"offline\", or outside the React render cycle.\r\n */\r\nfunction createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component, }) {\r\n    preloadedFeatures && loadFeatures(preloadedFeatures);\r\n    function MotionComponent(props, externalRef) {\r\n        const layoutId = useLayoutId(props);\r\n        props = Object.assign(Object.assign({}, props), { layoutId });\r\n        /**\r\n         * If we're rendering in a static environment, we only visually update the component\r\n         * as a result of a React-rerender rather than interactions or animations. This\r\n         * means we don't need to load additional memory structures like VisualElement,\r\n         * or any gesture/animation features.\r\n         */\r\n        const config = useContext(MotionConfigContext);\r\n        let features = null;\r\n        const context = useCreateMotionContext(props);\r\n        /**\r\n         * Create a unique projection ID for this component. If a new component is added\r\n         * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\r\n         * us to measure it as soon as any layout effect flushes pending layout animations.\r\n         *\r\n         * Performance note: It'd be better not to have to search the DOM for these elements.\r\n         * For newly-entering components it could be enough to only correct treeScale, in which\r\n         * case we could mount in a scale-correction mode. This wouldn't be enough for\r\n         * shared element transitions however. Perhaps for those we could revert to a root node\r\n         * that gets forceRendered and layout animations are triggered on its layout effect.\r\n         */\r\n        const projectionId = config.isStatic ? undefined : useProjectionId();\r\n        /**\r\n         *\r\n         */\r\n        const visualState = useVisualState(props, config.isStatic);\r\n        if (!config.isStatic && isBrowser) {\r\n            /**\r\n             * Create a VisualElement for this component. A VisualElement provides a common\r\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\r\n             * providing a way of rendering to these APIs outside of the React render loop\r\n             * for more performant animations and interactions\r\n             */\r\n            context.visualElement = useVisualElement(Component, visualState, Object.assign(Object.assign({}, config), props), createVisualElement);\r\n            useProjection(projectionId, props, context.visualElement, projectionNodeConstructor ||\r\n                featureDefinitions.projectionNodeConstructor);\r\n            /**\r\n             * Load Motion gesture and animation features. These are rendered as renderless\r\n             * components so each feature can optionally make use of React lifecycle methods.\r\n             */\r\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\r\n        }\r\n        /**\r\n         * The mount order and hierarchy is specific to ensure our element ref\r\n         * is hydrated by the time features fire their effects.\r\n         */\r\n        return (React.createElement(VisualElementHandler, { visualElement: context.visualElement, props: Object.assign(Object.assign({}, config), props) },\r\n            features,\r\n            React.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement))));\r\n    }\r\n    return forwardRef(MotionComponent);\r\n}\r\nfunction useLayoutId({ layoutId }) {\r\n    var _a;\r\n    const layoutGroupId = (_a = useContext(LayoutGroupContext)) === null || _a === void 0 ? void 0 : _a.id;\r\n    return layoutGroupId && layoutId !== undefined\r\n        ? layoutGroupId + \"-\" + layoutId\r\n        : layoutId;\r\n}\r\n\r\nexport { createMotionComponent };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}