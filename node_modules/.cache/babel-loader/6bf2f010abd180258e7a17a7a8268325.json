{"ast":null,"code":"import sync from 'framesync';\nimport React__default, { useContext } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\n\nclass MeasureLayoutWithContext extends React__default.Component {\n  /**\r\n   * This only mounts projection nodes for components that\r\n   * need measuring, we might want to do it for all components\r\n   * in order to incorporate transforms\r\n   */\n  componentDidMount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup,\n      layoutId\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    addScaleCorrector(defaultScaleCorrectors);\n\n    if (projection) {\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.add(projection);\n\n      if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n\n      projection.root.didUpdate();\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions(Object.assign(Object.assign({}, projection.options), {\n        onExitComplete: () => this.safeToRemove()\n      }));\n    }\n\n    globalProjectionState.hasEverUpdated = true;\n  }\n\n  getSnapshotBeforeUpdate(prevProps) {\n    const {\n      layoutDependency,\n      visualElement,\n      drag,\n      isPresent\n    } = this.props;\n    const projection = visualElement.projection;\n    if (!projection) return null;\n    /**\r\n     * TODO: We use this data in relegate to determine whether to\r\n     * promote a previous element. There's no guarantee its presence data\r\n     * will have updated by this point - if a bug like this arises it will\r\n     * have to be that we markForRelegation and then find a new lead some other way,\r\n     * perhaps in didUpdate\r\n     */\n\n    projection.isPresent = isPresent;\n\n    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        /**\r\n         * If there's another stack member taking over from this one,\r\n         * it's in charge of the exit animation and therefore should\r\n         * be in charge of the safe to remove. Otherwise we call it here.\r\n         */\n        sync.postRender(() => {\n          var _a;\n\n          if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n\n    return null;\n  }\n\n  componentDidUpdate() {\n    const {\n      projection\n    } = this.props.visualElement;\n\n    if (projection) {\n      projection.root.didUpdate();\n\n      if (!projection.currentAnimation && projection.isLead()) {\n        this.safeToRemove();\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup: promoteContext\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group) layoutGroup.group.remove(projection);\n      if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister) promoteContext.deregister(projection);\n    }\n  }\n\n  safeToRemove() {\n    const {\n      safeToRemove\n    } = this.props;\n    safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n  }\n\n  render() {\n    return null;\n  }\n\n}\n\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = useContext(LayoutGroupContext);\n  return React__default.createElement(MeasureLayoutWithContext, Object.assign({}, props, {\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  }));\n}\n\nconst defaultScaleCorrectors = {\n  borderRadius: Object.assign(Object.assign({}, correctBorderRadius), {\n    applyTo: [\"borderTopLeftRadius\", \"borderTopRightRadius\", \"borderBottomLeftRadius\", \"borderBottomRightRadius\"]\n  }),\n  borderTopLeftRadius: correctBorderRadius,\n  borderTopRightRadius: correctBorderRadius,\n  borderBottomLeftRadius: correctBorderRadius,\n  borderBottomRightRadius: correctBorderRadius,\n  boxShadow: correctBoxShadow\n};\nexport { MeasureLayout };","map":{"version":3,"names":["sync","React__default","useContext","usePresence","LayoutGroupContext","SwitchLayoutGroupContext","globalProjectionState","correctBorderRadius","correctBoxShadow","addScaleCorrector","MeasureLayoutWithContext","Component","componentDidMount","visualElement","layoutGroup","switchLayoutGroup","layoutId","props","projection","defaultScaleCorrectors","group","add","register","root","didUpdate","addEventListener","safeToRemove","setOptions","Object","assign","options","onExitComplete","hasEverUpdated","getSnapshotBeforeUpdate","prevProps","layoutDependency","drag","isPresent","undefined","willUpdate","promote","relegate","postRender","_a","getStack","members","length","componentDidUpdate","currentAnimation","isLead","componentWillUnmount","promoteContext","scheduleCheckAfterUnmount","remove","deregister","render","MeasureLayout","createElement","borderRadius","applyTo","borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius","boxShadow"],"sources":["C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs"],"sourcesContent":["import sync from 'framesync';\r\nimport React__default, { useContext } from 'react';\r\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\r\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\r\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\r\nimport { globalProjectionState } from '../../../projection/node/state.mjs';\r\nimport { correctBorderRadius } from '../../../projection/styles/scale-border-radius.mjs';\r\nimport { correctBoxShadow } from '../../../projection/styles/scale-box-shadow.mjs';\r\nimport { addScaleCorrector } from '../../../projection/styles/scale-correction.mjs';\r\n\r\nclass MeasureLayoutWithContext extends React__default.Component {\r\n    /**\r\n     * This only mounts projection nodes for components that\r\n     * need measuring, we might want to do it for all components\r\n     * in order to incorporate transforms\r\n     */\r\n    componentDidMount() {\r\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;\r\n        const { projection } = visualElement;\r\n        addScaleCorrector(defaultScaleCorrectors);\r\n        if (projection) {\r\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\r\n                layoutGroup.group.add(projection);\r\n            if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {\r\n                switchLayoutGroup.register(projection);\r\n            }\r\n            projection.root.didUpdate();\r\n            projection.addEventListener(\"animationComplete\", () => {\r\n                this.safeToRemove();\r\n            });\r\n            projection.setOptions(Object.assign(Object.assign({}, projection.options), { onExitComplete: () => this.safeToRemove() }));\r\n        }\r\n        globalProjectionState.hasEverUpdated = true;\r\n    }\r\n    getSnapshotBeforeUpdate(prevProps) {\r\n        const { layoutDependency, visualElement, drag, isPresent } = this.props;\r\n        const projection = visualElement.projection;\r\n        if (!projection)\r\n            return null;\r\n        /**\r\n         * TODO: We use this data in relegate to determine whether to\r\n         * promote a previous element. There's no guarantee its presence data\r\n         * will have updated by this point - if a bug like this arises it will\r\n         * have to be that we markForRelegation and then find a new lead some other way,\r\n         * perhaps in didUpdate\r\n         */\r\n        projection.isPresent = isPresent;\r\n        if (drag ||\r\n            prevProps.layoutDependency !== layoutDependency ||\r\n            layoutDependency === undefined) {\r\n            projection.willUpdate();\r\n        }\r\n        else {\r\n            this.safeToRemove();\r\n        }\r\n        if (prevProps.isPresent !== isPresent) {\r\n            if (isPresent) {\r\n                projection.promote();\r\n            }\r\n            else if (!projection.relegate()) {\r\n                /**\r\n                 * If there's another stack member taking over from this one,\r\n                 * it's in charge of the exit animation and therefore should\r\n                 * be in charge of the safe to remove. Otherwise we call it here.\r\n                 */\r\n                sync.postRender(() => {\r\n                    var _a;\r\n                    if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\r\n                        this.safeToRemove();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    componentDidUpdate() {\r\n        const { projection } = this.props.visualElement;\r\n        if (projection) {\r\n            projection.root.didUpdate();\r\n            if (!projection.currentAnimation && projection.isLead()) {\r\n                this.safeToRemove();\r\n            }\r\n        }\r\n    }\r\n    componentWillUnmount() {\r\n        const { visualElement, layoutGroup, switchLayoutGroup: promoteContext, } = this.props;\r\n        const { projection } = visualElement;\r\n        if (projection) {\r\n            projection.scheduleCheckAfterUnmount();\r\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\r\n                layoutGroup.group.remove(projection);\r\n            if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)\r\n                promoteContext.deregister(projection);\r\n        }\r\n    }\r\n    safeToRemove() {\r\n        const { safeToRemove } = this.props;\r\n        safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\r\n    }\r\n    render() {\r\n        return null;\r\n    }\r\n}\r\nfunction MeasureLayout(props) {\r\n    const [isPresent, safeToRemove] = usePresence();\r\n    const layoutGroup = useContext(LayoutGroupContext);\r\n    return (React__default.createElement(MeasureLayoutWithContext, Object.assign({}, props, { layoutGroup: layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove })));\r\n}\r\nconst defaultScaleCorrectors = {\r\n    borderRadius: Object.assign(Object.assign({}, correctBorderRadius), { applyTo: [\r\n            \"borderTopLeftRadius\",\r\n            \"borderTopRightRadius\",\r\n            \"borderBottomLeftRadius\",\r\n            \"borderBottomRightRadius\",\r\n        ] }),\r\n    borderTopLeftRadius: correctBorderRadius,\r\n    borderTopRightRadius: correctBorderRadius,\r\n    borderBottomLeftRadius: correctBorderRadius,\r\n    borderBottomRightRadius: correctBorderRadius,\r\n    boxShadow: correctBoxShadow,\r\n};\r\n\r\nexport { MeasureLayout };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}