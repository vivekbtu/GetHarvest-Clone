{"ast":null,"code":"import { __rest } from 'tslib';\n/**\r\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\r\n * element, so even though these handlers might all be triggered by different\r\n * observers, we can keep them in the same map.\r\n */\n\nconst observerCallbacks = new WeakMap();\n/**\r\n * Multiple observers can be created for multiple element/document roots. Each with\r\n * different settings. So here we store dictionaries of observers to each root,\r\n * using serialised settings (threshold/margin) as lookup keys.\r\n */\n\nconst observers = new WeakMap();\n\nconst fireObserverCallback = entry => {\n  var _a;\n\n  (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n};\n\nconst fireAllObserverCallbacks = entries => {\n  entries.forEach(fireObserverCallback);\n};\n\nfunction initIntersectionObserver(_a) {\n  var {\n    root\n  } = _a,\n      options = __rest(_a, [\"root\"]);\n\n  const lookupRoot = root || document;\n  /**\r\n   * If we don't have an observer lookup map for this root, create one.\r\n   */\n\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n\n  const rootObservers = observers.get(lookupRoot);\n  const key = JSON.stringify(options);\n  /**\r\n   * If we don't have an observer for this combination of root and settings,\r\n   * create one.\r\n   */\n\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, Object.assign({\n      root\n    }, options));\n  }\n\n  return rootObservers[key];\n}\n\nfunction observeIntersection(element, options, callback) {\n  const rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return () => {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\n\nexport { observeIntersection };","map":{"version":3,"names":["__rest","observerCallbacks","WeakMap","observers","fireObserverCallback","entry","_a","get","target","fireAllObserverCallbacks","entries","forEach","initIntersectionObserver","root","options","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","Object","assign","observeIntersection","element","callback","rootInteresectionObserver","observe","delete","unobserve"],"sources":["C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs"],"sourcesContent":["import { __rest } from 'tslib';\r\n\r\n/**\r\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\r\n * element, so even though these handlers might all be triggered by different\r\n * observers, we can keep them in the same map.\r\n */\r\nconst observerCallbacks = new WeakMap();\r\n/**\r\n * Multiple observers can be created for multiple element/document roots. Each with\r\n * different settings. So here we store dictionaries of observers to each root,\r\n * using serialised settings (threshold/margin) as lookup keys.\r\n */\r\nconst observers = new WeakMap();\r\nconst fireObserverCallback = (entry) => {\r\n    var _a;\r\n    (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\r\n};\r\nconst fireAllObserverCallbacks = (entries) => {\r\n    entries.forEach(fireObserverCallback);\r\n};\r\nfunction initIntersectionObserver(_a) {\r\n    var { root } = _a, options = __rest(_a, [\"root\"]);\r\n    const lookupRoot = root || document;\r\n    /**\r\n     * If we don't have an observer lookup map for this root, create one.\r\n     */\r\n    if (!observers.has(lookupRoot)) {\r\n        observers.set(lookupRoot, {});\r\n    }\r\n    const rootObservers = observers.get(lookupRoot);\r\n    const key = JSON.stringify(options);\r\n    /**\r\n     * If we don't have an observer for this combination of root and settings,\r\n     * create one.\r\n     */\r\n    if (!rootObservers[key]) {\r\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, Object.assign({ root }, options));\r\n    }\r\n    return rootObservers[key];\r\n}\r\nfunction observeIntersection(element, options, callback) {\r\n    const rootInteresectionObserver = initIntersectionObserver(options);\r\n    observerCallbacks.set(element, callback);\r\n    rootInteresectionObserver.observe(element);\r\n    return () => {\r\n        observerCallbacks.delete(element);\r\n        rootInteresectionObserver.unobserve(element);\r\n    };\r\n}\r\n\r\nexport { observeIntersection };\r\n"],"mappings":"AAAA,SAASA,MAAT,QAAuB,OAAvB;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAiB,GAAG,IAAIC,OAAJ,EAA1B;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,SAAS,GAAG,IAAID,OAAJ,EAAlB;;AACA,MAAME,oBAAoB,GAAIC,KAAD,IAAW;EACpC,IAAIC,EAAJ;;EACA,CAACA,EAAE,GAAGL,iBAAiB,CAACM,GAAlB,CAAsBF,KAAK,CAACG,MAA5B,CAAN,MAA+C,IAA/C,IAAuDF,EAAE,KAAK,KAAK,CAAnE,GAAuE,KAAK,CAA5E,GAAgFA,EAAE,CAACD,KAAD,CAAlF;AACH,CAHD;;AAIA,MAAMI,wBAAwB,GAAIC,OAAD,IAAa;EAC1CA,OAAO,CAACC,OAAR,CAAgBP,oBAAhB;AACH,CAFD;;AAGA,SAASQ,wBAAT,CAAkCN,EAAlC,EAAsC;EAClC,IAAI;IAAEO;EAAF,IAAWP,EAAf;EAAA,IAAmBQ,OAAO,GAAGd,MAAM,CAACM,EAAD,EAAK,CAAC,MAAD,CAAL,CAAnC;;EACA,MAAMS,UAAU,GAAGF,IAAI,IAAIG,QAA3B;EACA;AACJ;AACA;;EACI,IAAI,CAACb,SAAS,CAACc,GAAV,CAAcF,UAAd,CAAL,EAAgC;IAC5BZ,SAAS,CAACe,GAAV,CAAcH,UAAd,EAA0B,EAA1B;EACH;;EACD,MAAMI,aAAa,GAAGhB,SAAS,CAACI,GAAV,CAAcQ,UAAd,CAAtB;EACA,MAAMK,GAAG,GAAGC,IAAI,CAACC,SAAL,CAAeR,OAAf,CAAZ;EACA;AACJ;AACA;AACA;;EACI,IAAI,CAACK,aAAa,CAACC,GAAD,CAAlB,EAAyB;IACrBD,aAAa,CAACC,GAAD,CAAb,GAAqB,IAAIG,oBAAJ,CAAyBd,wBAAzB,EAAmDe,MAAM,CAACC,MAAP,CAAc;MAAEZ;IAAF,CAAd,EAAwBC,OAAxB,CAAnD,CAArB;EACH;;EACD,OAAOK,aAAa,CAACC,GAAD,CAApB;AACH;;AACD,SAASM,mBAAT,CAA6BC,OAA7B,EAAsCb,OAAtC,EAA+Cc,QAA/C,EAAyD;EACrD,MAAMC,yBAAyB,GAAGjB,wBAAwB,CAACE,OAAD,CAA1D;EACAb,iBAAiB,CAACiB,GAAlB,CAAsBS,OAAtB,EAA+BC,QAA/B;EACAC,yBAAyB,CAACC,OAA1B,CAAkCH,OAAlC;EACA,OAAO,MAAM;IACT1B,iBAAiB,CAAC8B,MAAlB,CAAyBJ,OAAzB;IACAE,yBAAyB,CAACG,SAA1B,CAAoCL,OAApC;EACH,CAHD;AAIH;;AAED,SAASD,mBAAT"},"metadata":{},"sourceType":"module"}