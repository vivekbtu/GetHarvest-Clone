{"ast":null,"code":"import _slicedToArray from \"C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { __rest } from 'tslib';\nimport { startAnimation } from '../../animation/utils/transitions.mjs';\nimport { setTarget } from './setters.mjs';\nimport { resolveVariant } from './variants.mjs';\nimport { isTransformProp } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\n\nfunction animateVisualElement(visualElement, definition) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  visualElement.notifyAnimationStart(definition);\n  var animation;\n\n  if (Array.isArray(definition)) {\n    var animations = definition.map(function (variant) {\n      return animateVariant(visualElement, variant, options);\n    });\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n\n  return animation.then(function () {\n    return visualElement.notifyAnimationComplete(definition);\n  });\n}\n\nfunction animateVariant(visualElement, variant) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  var resolved = resolveVariant(visualElement, variant, options.custom);\n\n  var _ref = resolved || {},\n      _ref$transition = _ref.transition,\n      transition = _ref$transition === void 0 ? visualElement.getDefaultTransition() || {} : _ref$transition;\n\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\r\n   * If we have a variant, create a callback that runs it as an animation.\r\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n   */\n\n\n  var getAnimation = resolved ? function () {\n    return animateTarget(visualElement, resolved, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\r\n   * If we have children, create a callback that runs all their animations.\r\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n   */\n\n  var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function () {\n    var forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var _transition = transition,\n        _transition$delayChil = _transition.delayChildren,\n        delayChildren = _transition$delayChil === void 0 ? 0 : _transition$delayChil,\n        staggerChildren = _transition.staggerChildren,\n        staggerDirection = _transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\r\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\r\n   * this animation or all children animations before playing the other.\r\n   */\n\n  var _transition2 = transition,\n      when = _transition2.when;\n\n  if (when) {\n    var _ref2 = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation],\n        _ref3 = _slicedToArray(_ref2, 2),\n        first = _ref3[0],\n        last = _ref3[1];\n\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\r\n * @internal\r\n */\n\n\nfunction animateTarget(visualElement, definition) {\n  var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n      _ref4$delay = _ref4.delay,\n      delay = _ref4$delay === void 0 ? 0 : _ref4$delay,\n      transitionOverride = _ref4.transitionOverride,\n      type = _ref4.type;\n\n  var _a;\n\n  var _b = visualElement.makeTargetAnimatable(definition),\n      _b$transition = _b.transition,\n      transition = _b$transition === void 0 ? visualElement.getDefaultTransition() : _b$transition,\n      transitionEnd = _b.transitionEnd,\n      target = __rest(_b, [\"transition\", \"transitionEnd\"]);\n\n  var willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride) transition = transitionOverride;\n  var animations = [];\n  var animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n\n  var _loop = function _loop(key) {\n    var value = visualElement.getValue(key);\n    var valueTarget = target[key];\n\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      return \"continue\";\n    }\n\n    var valueTransition = Object.assign({\n      delay: delay\n    }, transition);\n    /**\r\n     * Make animation instant if this is a transform prop and we should reduce motion.\r\n     */\n\n    if (visualElement.shouldReduceMotion && isTransformProp(key)) {\n      valueTransition = Object.assign(Object.assign({}, valueTransition), {\n        type: false,\n        delay: 0\n      });\n    }\n\n    var animation = startAnimation(key, value, valueTarget, valueTransition);\n\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(function () {\n        return willChange.remove(key);\n      });\n    }\n\n    animations.push(animation);\n  };\n\n  for (var key in target) {\n    var _ret = _loop(key);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return Promise.all(animations).then(function () {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\n\nfunction animateChildren(visualElement, variant) {\n  var delayChildren = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var staggerChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var staggerDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var options = arguments.length > 5 ? arguments[5] : undefined;\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return i * staggerChildren;\n  } : function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    animations.push(animateVariant(child, variant, Object.assign(Object.assign({}, options), {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notifyAnimationComplete(variant);\n    }));\n  });\n  return Promise.all(animations);\n}\n\nfunction stopAnimation(visualElement) {\n  visualElement.forEachValue(function (value) {\n    return value.stop();\n  });\n}\n\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\n\n\nfunction shouldBlockAnimation(_ref5, key) {\n  var protectedKeys = _ref5.protectedKeys,\n      needsAnimating = _ref5.needsAnimating;\n  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };","map":{"version":3,"names":["__rest","startAnimation","setTarget","resolveVariant","isTransformProp","isWillChangeMotionValue","animateVisualElement","visualElement","definition","options","notifyAnimationStart","animation","Array","isArray","animations","map","variant","animateVariant","Promise","all","resolvedDefinition","custom","animateTarget","then","notifyAnimationComplete","_a","resolved","transition","getDefaultTransition","transitionOverride","getAnimation","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","delay","type","_b","makeTargetAnimatable","transitionEnd","target","willChange","getValue","animationTypeState","animationState","getState","key","value","valueTarget","undefined","shouldBlockAnimation","valueTransition","Object","assign","shouldReduceMotion","add","remove","push","maxStaggerDuration","generateStaggerDuration","i","from","sort","sortByTreeOrder","forEach","child","stopAnimation","forEachValue","stop","a","b","sortNodePosition","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty"],"sources":["C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/framer-motion/dist/es/render/utils/animation.mjs"],"sourcesContent":["import { __rest } from 'tslib';\r\nimport { startAnimation } from '../../animation/utils/transitions.mjs';\r\nimport { setTarget } from './setters.mjs';\r\nimport { resolveVariant } from './variants.mjs';\r\nimport { isTransformProp } from '../html/utils/transform.mjs';\r\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\r\n\r\nfunction animateVisualElement(visualElement, definition, options = {}) {\r\n    visualElement.notifyAnimationStart(definition);\r\n    let animation;\r\n    if (Array.isArray(definition)) {\r\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\r\n        animation = Promise.all(animations);\r\n    }\r\n    else if (typeof definition === \"string\") {\r\n        animation = animateVariant(visualElement, definition, options);\r\n    }\r\n    else {\r\n        const resolvedDefinition = typeof definition === \"function\"\r\n            ? resolveVariant(visualElement, definition, options.custom)\r\n            : definition;\r\n        animation = animateTarget(visualElement, resolvedDefinition, options);\r\n    }\r\n    return animation.then(() => visualElement.notifyAnimationComplete(definition));\r\n}\r\nfunction animateVariant(visualElement, variant, options = {}) {\r\n    var _a;\r\n    const resolved = resolveVariant(visualElement, variant, options.custom);\r\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\r\n    if (options.transitionOverride) {\r\n        transition = options.transitionOverride;\r\n    }\r\n    /**\r\n     * If we have a variant, create a callback that runs it as an animation.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getAnimation = resolved\r\n        ? () => animateTarget(visualElement, resolved, options)\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If we have children, create a callback that runs all their animations.\r\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\r\n     */\r\n    const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\r\n        ? (forwardDelay = 0) => {\r\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\r\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\r\n        }\r\n        : () => Promise.resolve();\r\n    /**\r\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\r\n     * this animation or all children animations before playing the other.\r\n     */\r\n    const { when } = transition;\r\n    if (when) {\r\n        const [first, last] = when === \"beforeChildren\"\r\n            ? [getAnimation, getChildAnimations]\r\n            : [getChildAnimations, getAnimation];\r\n        return first().then(last);\r\n    }\r\n    else {\r\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\r\n    }\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction animateTarget(visualElement, definition, { delay = 0, transitionOverride, type } = {}) {\r\n    var _a;\r\n    let _b = visualElement.makeTargetAnimatable(definition), { transition = visualElement.getDefaultTransition(), transitionEnd } = _b, target = __rest(_b, [\"transition\", \"transitionEnd\"]);\r\n    const willChange = visualElement.getValue(\"willChange\");\r\n    if (transitionOverride)\r\n        transition = transitionOverride;\r\n    const animations = [];\r\n    const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\r\n    for (const key in target) {\r\n        const value = visualElement.getValue(key);\r\n        const valueTarget = target[key];\r\n        if (!value ||\r\n            valueTarget === undefined ||\r\n            (animationTypeState &&\r\n                shouldBlockAnimation(animationTypeState, key))) {\r\n            continue;\r\n        }\r\n        let valueTransition = Object.assign({ delay }, transition);\r\n        /**\r\n         * Make animation instant if this is a transform prop and we should reduce motion.\r\n         */\r\n        if (visualElement.shouldReduceMotion && isTransformProp(key)) {\r\n            valueTransition = Object.assign(Object.assign({}, valueTransition), { type: false, delay: 0 });\r\n        }\r\n        let animation = startAnimation(key, value, valueTarget, valueTransition);\r\n        if (isWillChangeMotionValue(willChange)) {\r\n            willChange.add(key);\r\n            animation = animation.then(() => willChange.remove(key));\r\n        }\r\n        animations.push(animation);\r\n    }\r\n    return Promise.all(animations).then(() => {\r\n        transitionEnd && setTarget(visualElement, transitionEnd);\r\n    });\r\n}\r\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\r\n    const animations = [];\r\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\r\n    const generateStaggerDuration = staggerDirection === 1\r\n        ? (i = 0) => i * staggerChildren\r\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\r\n    Array.from(visualElement.variantChildren)\r\n        .sort(sortByTreeOrder)\r\n        .forEach((child, i) => {\r\n        animations.push(animateVariant(child, variant, Object.assign(Object.assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(() => child.notifyAnimationComplete(variant)));\r\n    });\r\n    return Promise.all(animations);\r\n}\r\nfunction stopAnimation(visualElement) {\r\n    visualElement.forEachValue((value) => value.stop());\r\n}\r\nfunction sortByTreeOrder(a, b) {\r\n    return a.sortNodePosition(b);\r\n}\r\n/**\r\n * Decide whether we should block this animation. Previously, we achieved this\r\n * just by checking whether the key was listed in protectedKeys, but this\r\n * posed problems if an animation was triggered by afterChildren and protectedKeys\r\n * had been set to true in the meantime.\r\n */\r\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\r\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\r\n    needsAnimating[key] = false;\r\n    return shouldBlock;\r\n}\r\n\r\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}