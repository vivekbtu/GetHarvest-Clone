{"ast":null,"code":"import _defineProperty from \"C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { __rest } from 'tslib';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { animateVisualElement } from './animation.mjs';\nimport { AnimationType } from './types.mjs';\nimport { isVariantLabels, resolveVariant, isVariantLabel } from './variants.mjs';\nvar variantPriorityOrder = [AnimationType.Animate, AnimationType.InView, AnimationType.Focus, AnimationType.Hover, AnimationType.Tap, AnimationType.Drag, AnimationType.Exit];\nvar reversePriorityOrder = [].concat(variantPriorityOrder).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\n\nfunction animateList(visualElement) {\n  return function (animations) {\n    return Promise.all(animations.map(function (_ref) {\n      var animation = _ref.animation,\n          options = _ref.options;\n      return animateVisualElement(visualElement, animation, options);\n    }));\n  };\n}\n\nfunction createAnimationState(visualElement) {\n  var animate = animateList(visualElement);\n  var state = createState();\n  var isInitialRender = true;\n  /**\r\n   * This function will be used to reduce the animation definitions for\r\n   * each active animation type into an object of resolved values for it.\r\n   */\n\n  var buildResolvedTypeValues = function buildResolvedTypeValues(acc, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n\n    if (resolved) {\n      var transition = resolved.transition,\n          transitionEnd = resolved.transitionEnd,\n          target = __rest(resolved, [\"transition\", \"transitionEnd\"]);\n\n      acc = Object.assign(Object.assign(Object.assign({}, acc), target), transitionEnd);\n    }\n\n    return acc;\n  };\n  /**\r\n   * This just allows us to inject mocked animation functions\r\n   * @internal\r\n   */\n\n\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\r\n   * When we receive new props, we need to:\r\n   * 1. Create a list of protected keys for each type. This is a directory of\r\n   *    value keys that are currently being \"handled\" by types of a higher priority\r\n   *    so that whenever an animation is played of a given type, these values are\r\n   *    protected from being animated.\r\n   * 2. Determine if an animation type needs animating.\r\n   * 3. Determine if any values have been removed from a type and figure out\r\n   *    what to animate those to.\r\n   */\n\n\n  function animateChanges(options, changedActiveType) {\n    var _a;\n\n    var props = visualElement.getProps();\n    var context = visualElement.getVariantContext(true) || {};\n    /**\r\n     * A list of animations that we'll build into as we iterate through the animation\r\n     * types. This will get executed at the end of the function.\r\n     */\n\n    var animations = [];\n    /**\r\n     * Keep track of which values have been removed. Then, as we hit lower priority\r\n     * animation types, we can check if they contain removed values and animate to that.\r\n     */\n\n    var removedKeys = new Set();\n    /**\r\n     * A dictionary of all encountered keys. This is an object to let us build into and\r\n     * copy it without iteration. Each time we hit an animation type we set its protected\r\n     * keys - the keys its not allowed to animate - to the latest version of this object.\r\n     */\n\n    var encounteredKeys = {};\n    /**\r\n     * If a variant has been removed at a given index, and this component is controlling\r\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n     */\n\n    var removedVariantIndex = Infinity;\n    /**\r\n     * Iterate through all animation types in reverse priority order. For each, we want to\r\n     * detect which values it's handling and whether or not they've changed (and therefore\r\n     * need to be animated). If any values have been removed, we want to detect those in\r\n     * lower priority props and flag for animation.\r\n     */\n\n    var _loop = function _loop(i) {\n      var type = reversePriorityOrder[i];\n      var typeState = state[type];\n      var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n      var propIsVariant = isVariantLabel(prop);\n      /**\r\n       * If this type has *just* changed isActive status, set activeDelta\r\n       * to that status. Otherwise set to null.\r\n       */\n\n      var activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\r\n       * If this prop is an inherited variant, rather than been set directly on the\r\n       * component itself, we want to make sure we allow the parent to trigger animations.\r\n       *\r\n       * TODO: Can probably change this to a !isControllingVariants check\r\n       */\n\n      var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\r\n       *\r\n       */\n\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\r\n       * Set all encountered keys so far as the protected keys for this type. This will\r\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n       */\n\n\n      typeState.protectedKeys = Object.assign({}, encounteredKeys); // Check if we can skip analysing this prop early\n\n      if ( // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        return \"continue\";\n      }\n      /**\r\n       * As we go look through the values defined on this type, if we detect\r\n       * a changed value or a value that was removed in a higher priority, we set\r\n       * this to true and add this prop to the animation list.\r\n       */\n\n\n      var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      var shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      /**\r\n       * As animations can be set as variant lists, variants or target objects, we\r\n       * coerce everything to an array if it isn't one already\r\n       */\n\n      var definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\r\n       * Build an object of all the resolved values. We'll use this in the subsequent\r\n       * animateChanges calls to determine whether a value has changed.\r\n       */\n\n      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\r\n       * Now we need to loop through all the keys in the prev prop and this prop,\r\n       * and decide:\r\n       * 1. If the value has changed, and needs animating\r\n       * 2. If it has been removed, and needs adding to the removedKeys set\r\n       * 3. If it has been removed in a higher priority type and needs animating\r\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n       *    needs adding to the type's protectedKeys list.\r\n       */\n\n      var _typeState$prevResolv = typeState.prevResolvedValues,\n          prevResolvedValues = _typeState$prevResolv === void 0 ? {} : _typeState$prevResolv;\n      var allKeys = Object.assign(Object.assign({}, prevResolvedValues), resolvedValues);\n\n      var markToAnimate = function markToAnimate(key) {\n        shouldAnimateType = true;\n        removedKeys.delete(key);\n        typeState.needsAnimating[key] = true;\n      };\n\n      for (var key in allKeys) {\n        var next = resolvedValues[key];\n        var prev = prevResolvedValues[key]; // If we've already handled this we can just skip ahead\n\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\r\n         * If the value has changed, we probably want to animate it.\r\n         */\n\n        if (next !== prev) {\n          /**\r\n           * If both values are keyframes, we need to shallow compare them to\r\n           * detect whether any value has changed. If it has, we animate it.\r\n           */\n          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n            if (!shallowCompare(next, prev) || variantDidChange) {\n              markToAnimate(key);\n            } else {\n              /**\r\n               * If it hasn't changed, we want to ensure it doesn't animate by\r\n               * adding it to the list of protected keys.\r\n               */\n              typeState.protectedKeys[key] = true;\n            }\n          } else if (next !== undefined) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\r\n           * If next hasn't changed and it isn't undefined, we want to check if it's\r\n           * been removed by a higher priority\r\n           */\n          markToAnimate(key);\n        } else {\n          /**\r\n           * If it hasn't changed, we add it to the list of protected values\r\n           * to ensure it doesn't get animated.\r\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\r\n       * Update the typeState so next time animateChanges is called we can compare the\r\n       * latest prop and resolvedValues to these.\r\n       */\n\n\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\r\n       *\r\n       */\n\n      if (typeState.isActive) {\n        encounteredKeys = Object.assign(Object.assign({}, encounteredKeys), resolvedValues);\n      }\n\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\r\n       * If this is an inherited prop we want to hard-block animations\r\n       * TODO: Test as this should probably still handle animations triggered\r\n       * by removed values?\r\n       */\n\n\n      if (shouldAnimateType && !isInherited) {\n        animations.push.apply(animations, _toConsumableArray(definitionList.map(function (animation) {\n          return {\n            animation: animation,\n            options: Object.assign({\n              type: type\n            }, options)\n          };\n        })));\n      }\n    };\n\n    for (var i = 0; i < numAnimationTypes; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n    }\n    /**\r\n     * If there are some removed value that haven't been dealt with,\r\n     * we need to create a new animation that falls back either to the value\r\n     * defined in the style prop, or the last read value.\r\n     */\n\n\n    if (removedKeys.size) {\n      var fallbackAnimation = {};\n      removedKeys.forEach(function (key) {\n        var fallbackTarget = visualElement.getBaseTarget(key);\n\n        if (fallbackTarget !== undefined) {\n          fallbackAnimation[key] = fallbackTarget;\n        }\n      });\n      animations.push({\n        animation: fallbackAnimation\n      });\n    }\n\n    var shouldAnimate = Boolean(animations.length);\n\n    if (isInitialRender && props.initial === false && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\r\n   * Change whether a certain animation type is active.\r\n   */\n\n\n  function setActive(type, isActive, options) {\n    var _a; // If the active state hasn't changed, we can safely do nothing here\n\n\n    if (state[type].isActive === isActive) return Promise.resolve(); // Propagate active change to children\n\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n      var _a;\n\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    var animations = animateChanges(options, type);\n\n    for (var key in state) {\n      state[key].protectedKeys = {};\n    }\n\n    return animations;\n  }\n\n  return {\n    animateChanges: animateChanges,\n    setActive: setActive,\n    setAnimateFunction: setAnimateFunction,\n    getState: function getState() {\n      return state;\n    }\n  };\n}\n\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (isVariantLabels(next)) {\n    return !shallowCompare(next, prev);\n  }\n\n  return false;\n}\n\nfunction createTypeState() {\n  var isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return {\n    isActive: isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\n\nfunction createState() {\n  var _ref2;\n\n  return _ref2 = {}, _defineProperty(_ref2, AnimationType.Animate, createTypeState(true)), _defineProperty(_ref2, AnimationType.InView, createTypeState()), _defineProperty(_ref2, AnimationType.Hover, createTypeState()), _defineProperty(_ref2, AnimationType.Tap, createTypeState()), _defineProperty(_ref2, AnimationType.Drag, createTypeState()), _defineProperty(_ref2, AnimationType.Focus, createTypeState()), _defineProperty(_ref2, AnimationType.Exit, createTypeState()), _ref2;\n}\n\nexport { checkVariantsDidChange, createAnimationState, variantPriorityOrder };","map":{"version":3,"names":["__rest","isAnimationControls","isKeyframesTarget","shallowCompare","animateVisualElement","AnimationType","isVariantLabels","resolveVariant","isVariantLabel","variantPriorityOrder","Animate","InView","Focus","Hover","Tap","Drag","Exit","reversePriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","animation","options","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","acc","definition","resolved","transition","transitionEnd","target","Object","assign","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","_a","props","getProps","context","getVariantContext","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","type","typeState","prop","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","definitionList","Array","isArray","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","key","delete","needsAnimating","next","prev","hasOwnProperty","undefined","add","has","blockInitialAnimation","push","size","fallbackAnimation","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","initial","resolve","setActive","variantChildren","child","animationState","getState","createTypeState"],"sources":["C:/Users/bittu/Desktop/React-Unit4-Project/premium-grade-140/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"sourcesContent":["import { __rest } from 'tslib';\r\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\r\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\r\nimport { animateVisualElement } from './animation.mjs';\r\nimport { AnimationType } from './types.mjs';\r\nimport { isVariantLabels, resolveVariant, isVariantLabel } from './variants.mjs';\r\n\r\nconst variantPriorityOrder = [\r\n    AnimationType.Animate,\r\n    AnimationType.InView,\r\n    AnimationType.Focus,\r\n    AnimationType.Hover,\r\n    AnimationType.Tap,\r\n    AnimationType.Drag,\r\n    AnimationType.Exit,\r\n];\r\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\r\nconst numAnimationTypes = variantPriorityOrder.length;\r\nfunction animateList(visualElement) {\r\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\r\n}\r\nfunction createAnimationState(visualElement) {\r\n    let animate = animateList(visualElement);\r\n    const state = createState();\r\n    let isInitialRender = true;\r\n    /**\r\n     * This function will be used to reduce the animation definitions for\r\n     * each active animation type into an object of resolved values for it.\r\n     */\r\n    const buildResolvedTypeValues = (acc, definition) => {\r\n        const resolved = resolveVariant(visualElement, definition);\r\n        if (resolved) {\r\n            const { transition, transitionEnd } = resolved, target = __rest(resolved, [\"transition\", \"transitionEnd\"]);\r\n            acc = Object.assign(Object.assign(Object.assign({}, acc), target), transitionEnd);\r\n        }\r\n        return acc;\r\n    };\r\n    /**\r\n     * This just allows us to inject mocked animation functions\r\n     * @internal\r\n     */\r\n    function setAnimateFunction(makeAnimator) {\r\n        animate = makeAnimator(visualElement);\r\n    }\r\n    /**\r\n     * When we receive new props, we need to:\r\n     * 1. Create a list of protected keys for each type. This is a directory of\r\n     *    value keys that are currently being \"handled\" by types of a higher priority\r\n     *    so that whenever an animation is played of a given type, these values are\r\n     *    protected from being animated.\r\n     * 2. Determine if an animation type needs animating.\r\n     * 3. Determine if any values have been removed from a type and figure out\r\n     *    what to animate those to.\r\n     */\r\n    function animateChanges(options, changedActiveType) {\r\n        var _a;\r\n        const props = visualElement.getProps();\r\n        const context = visualElement.getVariantContext(true) || {};\r\n        /**\r\n         * A list of animations that we'll build into as we iterate through the animation\r\n         * types. This will get executed at the end of the function.\r\n         */\r\n        const animations = [];\r\n        /**\r\n         * Keep track of which values have been removed. Then, as we hit lower priority\r\n         * animation types, we can check if they contain removed values and animate to that.\r\n         */\r\n        const removedKeys = new Set();\r\n        /**\r\n         * A dictionary of all encountered keys. This is an object to let us build into and\r\n         * copy it without iteration. Each time we hit an animation type we set its protected\r\n         * keys - the keys its not allowed to animate - to the latest version of this object.\r\n         */\r\n        let encounteredKeys = {};\r\n        /**\r\n         * If a variant has been removed at a given index, and this component is controlling\r\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n         */\r\n        let removedVariantIndex = Infinity;\r\n        /**\r\n         * Iterate through all animation types in reverse priority order. For each, we want to\r\n         * detect which values it's handling and whether or not they've changed (and therefore\r\n         * need to be animated). If any values have been removed, we want to detect those in\r\n         * lower priority props and flag for animation.\r\n         */\r\n        for (let i = 0; i < numAnimationTypes; i++) {\r\n            const type = reversePriorityOrder[i];\r\n            const typeState = state[type];\r\n            const prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\r\n            const propIsVariant = isVariantLabel(prop);\r\n            /**\r\n             * If this type has *just* changed isActive status, set activeDelta\r\n             * to that status. Otherwise set to null.\r\n             */\r\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\r\n            if (activeDelta === false)\r\n                removedVariantIndex = i;\r\n            /**\r\n             * If this prop is an inherited variant, rather than been set directly on the\r\n             * component itself, we want to make sure we allow the parent to trigger animations.\r\n             *\r\n             * TODO: Can probably change this to a !isControllingVariants check\r\n             */\r\n            let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\r\n            /**\r\n             *\r\n             */\r\n            if (isInherited &&\r\n                isInitialRender &&\r\n                visualElement.manuallyAnimateOnMount) {\r\n                isInherited = false;\r\n            }\r\n            /**\r\n             * Set all encountered keys so far as the protected keys for this type. This will\r\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n             */\r\n            typeState.protectedKeys = Object.assign({}, encounteredKeys);\r\n            // Check if we can skip analysing this prop early\r\n            if (\r\n            // If it isn't active and hasn't *just* been set as inactive\r\n            (!typeState.isActive && activeDelta === null) ||\r\n                // If we didn't and don't have any defined prop for this animation type\r\n                (!prop && !typeState.prevProp) ||\r\n                // Or if the prop doesn't define an animation\r\n                isAnimationControls(prop) ||\r\n                typeof prop === \"boolean\") {\r\n                continue;\r\n            }\r\n            /**\r\n             * As we go look through the values defined on this type, if we detect\r\n             * a changed value or a value that was removed in a higher priority, we set\r\n             * this to true and add this prop to the animation list.\r\n             */\r\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\r\n            let shouldAnimateType = variantDidChange ||\r\n                // If we're making this variant active, we want to always make it active\r\n                (type === changedActiveType &&\r\n                    typeState.isActive &&\r\n                    !isInherited &&\r\n                    propIsVariant) ||\r\n                // If we removed a higher-priority variant (i is in reverse order)\r\n                (i > removedVariantIndex && propIsVariant);\r\n            /**\r\n             * As animations can be set as variant lists, variants or target objects, we\r\n             * coerce everything to an array if it isn't one already\r\n             */\r\n            const definitionList = Array.isArray(prop) ? prop : [prop];\r\n            /**\r\n             * Build an object of all the resolved values. We'll use this in the subsequent\r\n             * animateChanges calls to determine whether a value has changed.\r\n             */\r\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\r\n            if (activeDelta === false)\r\n                resolvedValues = {};\r\n            /**\r\n             * Now we need to loop through all the keys in the prev prop and this prop,\r\n             * and decide:\r\n             * 1. If the value has changed, and needs animating\r\n             * 2. If it has been removed, and needs adding to the removedKeys set\r\n             * 3. If it has been removed in a higher priority type and needs animating\r\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n             *    needs adding to the type's protectedKeys list.\r\n             */\r\n            const { prevResolvedValues = {} } = typeState;\r\n            const allKeys = Object.assign(Object.assign({}, prevResolvedValues), resolvedValues);\r\n            const markToAnimate = (key) => {\r\n                shouldAnimateType = true;\r\n                removedKeys.delete(key);\r\n                typeState.needsAnimating[key] = true;\r\n            };\r\n            for (const key in allKeys) {\r\n                const next = resolvedValues[key];\r\n                const prev = prevResolvedValues[key];\r\n                // If we've already handled this we can just skip ahead\r\n                if (encounteredKeys.hasOwnProperty(key))\r\n                    continue;\r\n                /**\r\n                 * If the value has changed, we probably want to animate it.\r\n                 */\r\n                if (next !== prev) {\r\n                    /**\r\n                     * If both values are keyframes, we need to shallow compare them to\r\n                     * detect whether any value has changed. If it has, we animate it.\r\n                     */\r\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\r\n                        if (!shallowCompare(next, prev) || variantDidChange) {\r\n                            markToAnimate(key);\r\n                        }\r\n                        else {\r\n                            /**\r\n                             * If it hasn't changed, we want to ensure it doesn't animate by\r\n                             * adding it to the list of protected keys.\r\n                             */\r\n                            typeState.protectedKeys[key] = true;\r\n                        }\r\n                    }\r\n                    else if (next !== undefined) {\r\n                        // If next is defined and doesn't equal prev, it needs animating\r\n                        markToAnimate(key);\r\n                    }\r\n                    else {\r\n                        // If it's undefined, it's been removed.\r\n                        removedKeys.add(key);\r\n                    }\r\n                }\r\n                else if (next !== undefined && removedKeys.has(key)) {\r\n                    /**\r\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\r\n                     * been removed by a higher priority\r\n                     */\r\n                    markToAnimate(key);\r\n                }\r\n                else {\r\n                    /**\r\n                     * If it hasn't changed, we add it to the list of protected values\r\n                     * to ensure it doesn't get animated.\r\n                     */\r\n                    typeState.protectedKeys[key] = true;\r\n                }\r\n            }\r\n            /**\r\n             * Update the typeState so next time animateChanges is called we can compare the\r\n             * latest prop and resolvedValues to these.\r\n             */\r\n            typeState.prevProp = prop;\r\n            typeState.prevResolvedValues = resolvedValues;\r\n            /**\r\n             *\r\n             */\r\n            if (typeState.isActive) {\r\n                encounteredKeys = Object.assign(Object.assign({}, encounteredKeys), resolvedValues);\r\n            }\r\n            if (isInitialRender && visualElement.blockInitialAnimation) {\r\n                shouldAnimateType = false;\r\n            }\r\n            /**\r\n             * If this is an inherited prop we want to hard-block animations\r\n             * TODO: Test as this should probably still handle animations triggered\r\n             * by removed values?\r\n             */\r\n            if (shouldAnimateType && !isInherited) {\r\n                animations.push(...definitionList.map((animation) => ({\r\n                    animation: animation,\r\n                    options: Object.assign({ type }, options),\r\n                })));\r\n            }\r\n        }\r\n        /**\r\n         * If there are some removed value that haven't been dealt with,\r\n         * we need to create a new animation that falls back either to the value\r\n         * defined in the style prop, or the last read value.\r\n         */\r\n        if (removedKeys.size) {\r\n            const fallbackAnimation = {};\r\n            removedKeys.forEach((key) => {\r\n                const fallbackTarget = visualElement.getBaseTarget(key);\r\n                if (fallbackTarget !== undefined) {\r\n                    fallbackAnimation[key] = fallbackTarget;\r\n                }\r\n            });\r\n            animations.push({ animation: fallbackAnimation });\r\n        }\r\n        let shouldAnimate = Boolean(animations.length);\r\n        if (isInitialRender &&\r\n            props.initial === false &&\r\n            !visualElement.manuallyAnimateOnMount) {\r\n            shouldAnimate = false;\r\n        }\r\n        isInitialRender = false;\r\n        return shouldAnimate ? animate(animations) : Promise.resolve();\r\n    }\r\n    /**\r\n     * Change whether a certain animation type is active.\r\n     */\r\n    function setActive(type, isActive, options) {\r\n        var _a;\r\n        // If the active state hasn't changed, we can safely do nothing here\r\n        if (state[type].isActive === isActive)\r\n            return Promise.resolve();\r\n        // Propagate active change to children\r\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\r\n        state[type].isActive = isActive;\r\n        const animations = animateChanges(options, type);\r\n        for (const key in state) {\r\n            state[key].protectedKeys = {};\r\n        }\r\n        return animations;\r\n    }\r\n    return {\r\n        animateChanges,\r\n        setActive,\r\n        setAnimateFunction,\r\n        getState: () => state,\r\n    };\r\n}\r\nfunction checkVariantsDidChange(prev, next) {\r\n    if (typeof next === \"string\") {\r\n        return next !== prev;\r\n    }\r\n    else if (isVariantLabels(next)) {\r\n        return !shallowCompare(next, prev);\r\n    }\r\n    return false;\r\n}\r\nfunction createTypeState(isActive = false) {\r\n    return {\r\n        isActive,\r\n        protectedKeys: {},\r\n        needsAnimating: {},\r\n        prevResolvedValues: {},\r\n    };\r\n}\r\nfunction createState() {\r\n    return {\r\n        [AnimationType.Animate]: createTypeState(true),\r\n        [AnimationType.InView]: createTypeState(),\r\n        [AnimationType.Hover]: createTypeState(),\r\n        [AnimationType.Tap]: createTypeState(),\r\n        [AnimationType.Drag]: createTypeState(),\r\n        [AnimationType.Focus]: createTypeState(),\r\n        [AnimationType.Exit]: createTypeState(),\r\n    };\r\n}\r\n\r\nexport { checkVariantsDidChange, createAnimationState, variantPriorityOrder };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}